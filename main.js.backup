/*
        Main orchestrator: sets up canvas, input, camera, and plugs modules.
*/

// Using globals Player and Environment defined by separate scripts

const DEBUG = false;

const ENABLE_DEBUG_LOGS = false;
const ENABLE_DAMAGE_LOGS = true;

if (typeof window !== 'undefined' && window.console) {
    const allowDamageLog = (args) => {
        if (!Array.isArray(args) || args.length === 0) return false;
        for (let i = 0; i < args.length; i++) {
            const value = args[i];
            if (typeof value === 'string' && (
                value.includes('DAMAGE') ||
                value.includes('Damage') ||
                value.includes('hit flash') ||
                value.includes('Hit flash')
            )) {
                return true;
            }
        }
        return false;
    };

    ['log', 'debug', 'info'].forEach(level => {
        const original = window.console[level];
        if (typeof original !== 'function') return;

        if (!window.console[`__original_${level}`]) {
            window.console[`__original_${level}`] = original.bind(window.console);
        }

        if (ENABLE_DEBUG_LOGS) {
            window.console[level] = window.console[`__original_${level}`];
            return;
        }

        window.console[level] = (...args) => {
            if (ENABLE_DAMAGE_LOGS && allowDamageLog(args)) {
                window.console[`__original_${level}`](...args);
            }
        };
    });
}

// Debug: reduce Artillery Witch explosion damage to 1.
// To disable this debug damage, comment out the next line.
// window.DEBUG_ARTILLERY_LOW_DAMAGE = true;

/** @type {HTMLCanvasElement} */
let canvas = null;
let ctx = null;

function initializeCanvas() {
    canvas = document.getElementById('game');
    if (!canvas) {
        console.error('[Main] Canvas #game not found in DOM!');
        return false;
    }
    
    ctx = canvas.getContext('2d');
    if (DEBUG) console.log('[Main] Canvas and context initialized:', { canvas, hasCtx: !!ctx });
    return true;
}
window.addEventListener('error', (e) => {
        console.error('[Main] Global error:', e.message, e.error);
});
window.addEventListener('unhandledrejection', (e) => {
        console.error('[Main] Unhandled rejection:', e.reason);
});

const state = {
        viewportWidth: window.innerWidth,
        viewportHeight: window.innerHeight,
        lastTimestamp: 0,
        deathTimer: 0,
        cameraX: 0,
        cameraY: 0,
        keys: { KeyW: false, KeyA: false, KeyS: false, KeyD: false, ShiftLeft: false, ShiftRight: false, KeyE: false, Backquote: false, BracketRight: false },
        // Cheat/debug states
        invincible: false,
        mouse: { x: 0, y: 0 },
        mouseDown: false,
        justPressed: false,
        justReleased: false,
        justPressedKeyE: false,
        // UI interaction flags
        uiDragSlider: false,
        // Guidance arrow opacity (0..1)
        arrowAlpha: 0,
        // Extraction outcome overlay: null | { type: 'win'|'lose', reason?: string }
        extractionEnd: null,
        extractionButtonRect: null,
        // Track whether the artifact has ever been picked up in this run
        artifactEverPicked: false,
        // Track whether the boss has been spawned already (after artifact pickup)
        bossSpawned: false,
        // When true, freeze gameplay (on successful extraction pre-win)
        isFrozen: false,
        // Screen shake state
        shakeTime: 0,
        shakeDur: 0,
        shakeMag: 0,
        // Consecutive damage streak timer (seconds)
        damageStreakTime: 0,
        // 0..1 ramp that grows while taking damage and decays otherwise (controls amplitude easing)
        shakeProgress: 0,
        // Frequency/phase controls for smoother, controllable shake motion
        shakePhase: 0,
        shakeBaseAX: 0,
        shakeBaseAY: 0,
        shakeFreqHz: 0,
        // Damage vignette intensity 0..1 (fast rise on damage, slow decay)
        vignette: 0,
        // Quickbar fade timer when hiding (0..0.7)
        quickbarFade: 0
};

// CRITICAL: Defer ALL initialization until dependencies are loaded
// This prevents crashes from missing Player/Weapons/etc classes
let player = null;
let environment = null;
let worldInitialized = false;
let projectiles = null;
let enemies = null;
let director = null;
let ui = null;
let modeTimer = null;
let npcs = null;
window.npcs = null;

// Scene management: 'lobby' | 'level'
const scene = { current: 'lobby' };

// Bootstrap retry counter
window.__mainBootAttempts__ = 0;

// CRITICAL: Watchdog to ensure world initialization happens
let worldInitWatchdog = null;
function startWorldInitWatchdog() {
        if (worldInitWatchdog) return; // Already running
        
        worldInitWatchdog = setInterval(() => {
                // Check if we have everything needed for world initialization
                if (!worldInitialized && 
                    window.networkManager && 
                    window.networkManager.worldSeedReceived && 
                    typeof window.initializeWorld === 'function') {
                        
                        console.log('[Main] Watchdog triggering world initialization with seed:', window.networkManager.worldSeed);
                        initializeWorld(window.networkManager.worldSeed);
                        
                        // Clear watchdog after successful initialization
                        if (worldInitialized && worldInitWatchdog) {
                                clearInterval(worldInitWatchdog);
                                worldInitWatchdog = null;
                                console.log('[Main] World init watchdog cleared - initialization complete');
                        }
                }
        }, 500); // Check every 500ms
        
        console.log('[Main] World initialization watchdog started');
}

// Defer player placement until environment is initialized
function placePlayerRandomly() {
        // CRITICAL: Guard against null environment during deferred initialization
        if (!environment || !worldInitialized) {
                console.log('[Main] Environment not ready, deferring player placement');
                return;
        }
        
        const tries = 400;
        const clearance = Math.max(30, player.radius + 24);
        const b = environment.boundary - clearance - 10;
        for (let i = 0; i < tries; i++) {
                const nx = (Math.random() * 2 - 1) * b;
                const ny = (Math.random() * 2 - 1) * b;
                if (!environment.circleHitsAny(nx, ny, clearance) && environment.isInsideBounds(nx, ny, clearance)) {
                        player.x = nx; player.y = ny;
                        environment.spawnSafeX = nx; environment.spawnSafeY = ny; environment.spawnSafeRadius = Math.max(environment.spawnSafeRadius, clearance * 2);
                        console.log('[Main] Player placed at:', {x: nx, y: ny});
                        break;
                }
        }
}

// Spawn Merchant in Lobby at upper center
function spawnLobbyMerchant() {
    try {
        if (scene.current !== 'lobby') return;
        if (!window.Merchant) return;
        if (!environment || !worldInitialized) {
            console.log('[Main] Environment not ready, deferring merchant spawn');
            return;
        }
        const r = 24;
        const b = environment.boundary;
        // Upper center: x=0, y near top boundary with margin
        const x = 0;
        const y = -b + r + 80;
        // Ensure within bounds and not inside obstacle
        let mx = x, my = y;
        if (!environment.isInsideBounds(mx, my, r) || environment.circleHitsAny(mx, my, r)) {
            // Fallback: step down until clear
            for (let dy = 100; dy <= 600; dy += 60) {
                const ty = -b + r + 80 + dy;
                if (environment.isInsideBounds(x, ty, r) && !environment.circleHitsAny(x, ty, r)) { my = ty; break; }
            }
        }
        npcs.add(new window.Merchant(mx, my));
    } catch(_) {}
}

// Spawn Commander in Lobby at left-center  
function spawnLobbyCommander() {
    try {
        if (scene.current !== 'lobby') return;
        if (!window.Commander) return;
        if (!environment || !worldInitialized) {
            console.log('[Main] Environment not ready, deferring commander spawn');
            return;
        }
        const r = 24;
        const b = environment.boundary;
        // Left-center: x near left wall + margin; y = 0
        const x = -b + r + 140;
        const y = 0;
        let cx = x, cy = y;
        // If blocked, nudge inward until clear
        if (!environment.isInsideBounds(cx, cy, r) || environment.circleHitsAny(cx, cy, r)) {
            for (let step = 1; step <= 20; step++) {
                const nx = x + step * 20;
                if (environment.isInsideBounds(nx, y, r) && !environment.circleHitsAny(nx, y, r)) { cx = nx; cy = y; break; }
            }
        }
        npcs.add(new window.Commander(cx, cy));
    } catch(_) {}
}

// Spawn Target Dummy in Lobby at upper left corner  
function spawnTargetDummy() {
    try {
        if (scene.current !== 'lobby') return;
        if (!window.TargetDummy) return;
        if (!environment || !worldInitialized) {
            console.log('[Main] Environment not ready, deferring target dummy spawn');
            return;
        }
        
        // Request server to create target dummy instead of creating locally
        if (window.networkManager && window.networkManager.connected) {
            console.log('[Main] Requesting server to create target dummy');
            window.networkManager.requestTargetDummyCreation();
            return;
        }
        
        // Fallback to local creation if not connected to server (single player mode)
        createLocalTargetDummy();
    } catch(_) {}
}

function createLocalTargetDummy() {
    try {
        console.log('[Main] Creating local target dummy (single player mode)');
        
        // Remove existing target dummy if present
        for (let i = enemies.items.length - 1; i >= 0; i--) {
            if (enemies.items[i].isTargetDummy) {
                enemies.items.splice(i, 1);
            }
        }
        
        const r = 32; // TargetDummy radius
        const b = environment.boundary;
        // Upper left corner: x near left wall + margin; y near top wall + margin
        const x = -b + r + 100;  // Left side with margin
        const y = -b + r + 100;  // Top side with margin
        let tx = x, ty = y;
        
        // If blocked, find a clear spot nearby
        if (environment.isObstacle(tx, ty)) {
            console.log('[Main] Original target dummy position blocked, finding alternative');
            let found = false;
            const searchRadius = 200;
            for (let attempt = 0; attempt < 20 && !found; attempt++) {
                const angle = Math.random() * 2 * Math.PI;
                const dist = 50 + Math.random() * searchRadius;
                tx = x + Math.cos(angle) * dist;
                ty = y + Math.sin(angle) * dist;
                if (!environment.isObstacle(tx, ty)) {
                    found = true;
                }
            }
            if (!found) {
                console.log('[Main] Could not find clear spot for target dummy, using original position');
                tx = x; ty = y;
            }
        }
        
        console.log('[Main] Target dummy spawned at:', {x: tx, y: ty});
        const targetDummy = new window.TargetDummy(tx, ty);
        enemies.items.push(targetDummy);
        if (typeof enemies._insert === 'function') {
            enemies._insert(targetDummy);
        }
    } catch(e) {
        console.error('[Main] Error spawning target dummy:', e);
    }
}

// Initialize the world once the seed is received from the server
function initializeWorld(seed) {
    if (worldInitialized) {
        console.log('[Main] World already initialized, skipping');
        return;
    }
    
    console.log('[Main] Initializing world with seed:', seed);
    console.log('[Main] WorldRNG available?', typeof WorldRNG !== 'undefined');
    console.log('[Main] EnvironmentLobby available?', typeof window.EnvironmentLobby !== 'undefined');
    console.log('[Main] Environment available?', typeof Environment !== 'undefined');
    
    // Ensure WorldRNG is properly initialized
    if (typeof WorldRNG !== 'undefined' && WorldRNG.setSeed) {
        WorldRNG.setSeed(seed);
        console.log('[Main] WorldRNG initialized with seed:', seed);
    } else {
        console.error('[Main] WorldRNG not available! World generation will not be synchronized!');
    }
    
    // Now create the environment with seeded RNG
    try {
        environment = new (window.EnvironmentLobby || Environment)();
        console.log('[Main] Environment created successfully');
        
        // CRITICAL: Update window.environment so other systems can access it
        window.environment = environment;
        console.log('[Main] Environment assigned to window.environment');
        
        // CRITICAL: Initialize director after environment is created
        if (!director) {
                director = new Director(enemies, environment, player);
                window.director = director;
                console.log('[Main] Director initialized with environment');
        }
        
        worldInitialized = true;
        
        // Now that environment is ready, place the player and spawn NPCs
        placePlayerRandomly();
        spawnLobbyMerchant();
        spawnLobbyCommander();
        spawnTargetDummy();
        
        console.log('[Main] World initialization completed successfully');
    } catch (error) {
        console.error('[Main] Error creating environment:', error);
    }
}

// CRITICAL: Guarded bootstrap function to prevent crashes from missing dependencies
function boot() {
    console.log('[Main] Boot function starting - checking dependencies');
    
    // Check for required dependencies
    const deps = {
        Player: window.Player,
        Weapons: window.Weapons, 
        Enemies: window.Enemies,
        Environment: window.Environment,
        EnvironmentLobby: window.EnvironmentLobby,
        Director: window.Director,
        UI: window.UI,
        Mode: window.Mode || window.ModeTimer,
        NPCs: window.NPCs
    };
    
    const missing = Object.entries(deps).filter(([name, cls]) => !cls).map(([name]) => name);
    
    if (missing.length > 0) {
        console.error('[Main] Missing dependencies:', missing, 'retrying in 500ms...');
        return scheduleRetry();
    }
    
    console.log('[Main] All dependencies loaded, initializing game...');
    
    try {
        // Now safely create all game objects
        player = new Player(0, 0);
        projectiles = new Weapons();
        enemies = new Enemies();
        
        // Continue with original initialization...
        window.projectiles = projectiles;
        // Expose enemies globally so NPCs and other modules can query them
        window.enemies = enemies;
        // Neutral NPCs container
        npcs = new NPCs();
        window.npcs = npcs;
        ui = new UI();
        modeTimer = new (window.Mode || window.ModeTimer)();
        // Dialogue UI
        const dialogue = new DialogueBox();
// Dialogue data loader
const dialogueLoader = new (window.DialogueLoader || function(){ return class { async load(){ return null; } } })();
// Bridge for DialogueBox to trigger NPC actions
window.onNpcDialogueAction = function(effect, ctx) {
        try {
                if (!effect || !effect.type || effect.type !== 'npcAction') return;
                const npcId = (ctx && ctx.npcId != null) ? ctx.npcId : (dialogue && dialogue.npcId != null ? dialogue.npcId : null);
                if (npcId == null) return;
                let npc = null;
                for (let i = 0; i < npcs.items.length; i++) { const n = npcs.items[i]; if (n && n.id === npcId) { npc = n; break; } }
                if (!npc || typeof npc.switchState !== 'function') return;
                const map = { 'default': 'idle', 'follow': 'follow', 'hostile': 'hostile', 'run_to_boss': 'run_to_boss' };
                const next = map[effect.action] || effect.action;
                npc.switchState(next);
        } catch(_) {}
};
// Expose player for global access by pickups
window.player = player;
// Expose environment for modules that check bounds
window.environment = environment;
window.scene = scene;

// Multiplayer integration
let isMultiplayer = false;
// Mirror to global for modules that check window.isMultiplayer (e.g., enemy firing guards)
window.isMultiplayer = false;
let otherPlayers = [];

// Initialize multiplayer networking
function initializeMultiplayer() {
    if (typeof window.networkManager === 'undefined') {
        console.log('[Main] Network manager not available, running in single-player mode');
        return;
    }
    
    console.log('[Main] Initializing multiplayer networking');
    isMultiplayer = true;
    window.isMultiplayer = true;
    
    // Set up network event handlers
    window.networkManager.onConnected = () => {
        window.gameDebugger.networkConnect(window.networkManager.playerId, window.networkManager.roomId);
    };
    
    window.networkManager.onDisconnected = (reason) => {
        window.gameDebugger.networkDisconnect(window.networkManager.playerId, reason);
        otherPlayers = [];
    };
    
    window.networkManager.onGameStateUpdate = (gameState) => {
        // Sync ground items for late joiners (only add items we don't already have)
        if (Array.isArray(gameState.groundItems) && window.GameObjects && window.GameObjects.HexStat) {
            if (!Array.isArray(window.bossDrops)) window.bossDrops = [];
            const existingIds = new Set(window.bossDrops.filter(item => item._serverId).map(item => item._serverId));
            
            for (const item of gameState.groundItems) {
                if (!existingIds.has(item.id)) {
                    const HexStat = window.GameObjects.HexStat;
                    const rarity = { name: item.rarityName, color: item.color };
                    const hexStat = new HexStat(item.x, item.y, item.vx, item.vy, { 
                        label: item.label, 
                        fill: rarity.color, 
                        rarity: rarity 
                    });
                    hexStat.onGround = false;
                    hexStat._serverId = item.id;
                    window.bossDrops.push(hexStat);
                }
            }
        }
        
        // Find server player data
        const serverPlayer = gameState.players ? gameState.players.find(p => p.id === window.networkManager.playerId) : null;
        
        if (serverPlayer) {
            // Smooth position correction instead of rollback to prevent stuttering
            try {
                // Update server position first for accurate corrections
                window.networkManager.serverPosition = { x: serverPlayer.x, y: serverPlayer.y };
                
                const reconciliation = window.networkManager.processServerReconciliation(
                    serverPlayer,
                    gameState.lastProcessedInputSeq || 0
                );
                
                if (reconciliation && reconciliation.needsCorrection) {
                    // Use smooth correction instead of rollback to prevent stuttering
                    const correctionSpeed = 0.2; // Smooth correction factor
                    player.x += (reconciliation.serverPosition.x - player.x) * correctionSpeed;
                    player.y += (reconciliation.serverPosition.y - player.y) * correctionSpeed;
                } else if (reconciliation) {
                    // Simple reconciliation fallback
                    const distance = Math.sqrt(
                        Math.pow(player.x - reconciliation.serverPosition.x, 2) + 
                        Math.pow(player.y - reconciliation.serverPosition.y, 2)
                    );
                    
                    if (distance > 10) {
                        const correctionFactor = Math.min(distance / 50, 0.3);
                        player.x = window.networkManager.lerp(player.x, reconciliation.serverPosition.x, correctionFactor);
                        player.y = window.networkManager.lerp(player.y, reconciliation.serverPosition.y, correctionFactor);
                    }
                }
            } catch (error) {
                console.warn('[Main] Error in server reconciliation:', error);
                // Fallback to old simple reconciliation
                const distance = Math.sqrt(
                    Math.pow(player.x - serverPlayer.x, 2) + 
                    Math.pow(player.y - serverPlayer.y, 2)
                );
                
                if (distance > 50) {
                    const correctionFactor = Math.min(distance / 100, 0.5);
                    player.x = window.networkManager.lerp(player.x, serverPlayer.x, correctionFactor);
                    player.y = window.networkManager.lerp(player.y, serverPlayer.y, correctionFactor);
                }
            }
        }
        
        // Note: otherPlayers will be updated per-frame in render loop, not cached here
    };
    
    window.networkManager.onPlayerJoined = (playerData) => {
        window.gameDebugger.playerJoin(playerData.id, { x: playerData.x, y: playerData.y }, {
            roomId: window.networkManager.roomId,
            playerCount: otherPlayers.length + 1
        });
    };
    
    window.networkManager.onPlayerLeft = (data) => {
        window.gameDebugger.playerLeave(data.id, {
            roomId: window.networkManager.roomId,
            playerCount: otherPlayers.length
        });
    };
    
    // CRITICAL: Handle world seed from server for synchronized world generation
    window.networkManager.onWorldSeedReceived = (seed) => {
        console.log('[Main] Received world seed from server, initializing world:', seed);
        try {
            initializeWorld(seed);
        } catch (error) {
            console.error('[Main] Error initializing world:', error);
        }
    };
    
    // Connect to the server (gracefully handle missing socket.io)
    try {
        if (typeof window.io === 'undefined') {
            console.warn('[Main] socket.io not available; running in single-player mode');
            isMultiplayer = false;
            window.isMultiplayer = false;
        } else {
            window.networkManager.connect();
        }
    } catch (e) {
        console.warn('[Main] Failed to initialize multiplayer, falling back to single-player:', e);
        isMultiplayer = false;
        window.isMultiplayer = false;
    }
    
    // FALLBACK: Use fixed seed for all clients temporarily to bypass connection issues
    setTimeout(() => {
        if (!worldInitialized) {
            console.warn('[Main] FALLBACK: No world seed received from server, using temporary fixed seed');
            initializeWorld(508076041); // Use same seed as server generates
        }
    }, 2000); // Reduced to 2 seconds
}

// Function to render other players with per-frame interpolation
function renderOtherPlayers(ctx) {
    if (!isMultiplayer || !window.networkManager) return;
    
    // Get interpolated other players per frame (not cached)
    try {
        otherPlayers = window.networkManager.getOtherPlayers();
        if (otherPlayers.length === 0) return;
    } catch (error) {
        console.warn('[Main] Error getting other players:', error);
        return;
    }
    
    for (const otherPlayer of otherPlayers) {
        // Calculate screen position
        const screenX = otherPlayer.x - state.cameraX;
        const screenY = otherPlayer.y - state.cameraY;
        
        // Only render if on screen
        if (screenX < -50 || screenX > state.viewportWidth + 50 || 
            screenY < -50 || screenY > state.viewportHeight + 50) {
            continue;
        }
        
        // Speed trail (draw behind player body)
        if (otherPlayer._trailPoints && otherPlayer._trailPoints.length > 0) {
            for (let i = otherPlayer._trailPoints.length - 1; i >= 0; i--) {
                const p = otherPlayer._trailPoints[i];
                const k = Math.max(0, Math.min(1, p.life / (p.max || 0.001)));
                // Direction from player to this trail point (behind direction)
                const bx = p.x - otherPlayer.x;
                const by = p.y - otherPlayer.y;
                const bdist = Math.hypot(bx, by) || 0.0001;
                const bux = bx / bdist;
                const buy = by / bdist;
                // Length scales with current speed, but do not exceed distance to this point
                const baseSpeed = 220;
                const speedFactor = Math.max(0.75, Math.min(3, (otherPlayer._instantSpeed || 0) / baseSpeed));
                const maxLen = Math.min(70, 26 * speedFactor);
                const len = Math.min(maxLen, bdist) * k;
                // Start slightly behind the player's center so it never pokes out in front
                const inset = Math.max(0, (otherPlayer.radius || 20) * 0.55);
                const sx = (otherPlayer.x + bux * inset) - state.cameraX;
                const sy = (otherPlayer.y + buy * inset) - state.cameraY;
                const ex = sx + bux * len;
                const ey = sy + buy * len;
                ctx.save();
                // Softer overall opacity with stronger fade away from body (near sx -> ex)
                const nearA = 0.2 * k;
                const farA = 0.0;
                const grad = ctx.createLinearGradient(sx, sy, ex, ey);
                // Use different color for other players (darker blue trail)
                grad.addColorStop(0, `rgba(25, 118, 210, ${nearA})`); // #1976D2 with alpha
                grad.addColorStop(1, `rgba(25, 118, 210, ${farA})`);
                ctx.fillStyle = grad;
                // Build a tapered quad: wide at the near end, narrow at the far end
                const baseWidth = Math.max(2, (otherPlayer.radius || 20) * 1.2);
                const widthNear = baseWidth * k;
                const widthFar = baseWidth * k * 0.08; // very thin tail to avoid aliasing
                const px = -buy; // perpendicular
                const py = bux;
                const nxLx = sx + px * (widthNear * 0.5);
                const nxLy = sy + py * (widthNear * 0.5);
                const nxRx = sx - px * (widthNear * 0.5);
                const nxRy = sy - py * (widthNear * 0.5);
                const fxLx = ex + px * (widthFar * 0.5);
                const fxLy = ey + py * (widthFar * 0.5);
                const fxRx = ex - px * (widthFar * 0.5);
                const fxRy = ey - py * (widthFar * 0.5);
                ctx.beginPath();
                ctx.moveTo(nxLx, nxLy);
                ctx.lineTo(fxLx, fxLy);
                ctx.lineTo(fxRx, fxRy);
                ctx.lineTo(nxRx, nxRy);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // Aim direction indicator (draw UNDER player); hide while dead
        if (typeof otherPlayer.aimAngle === 'number' && (otherPlayer.health == null || otherPlayer.health > 0)) {
            const aimLength = 50; // Increased from 35 for better visibility
            const aimEndX = screenX + Math.cos(otherPlayer.aimAngle) * aimLength;
            const aimEndY = screenY + Math.sin(otherPlayer.aimAngle) * aimLength;
            
            // Aim line only (no arrow tip)
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            ctx.lineTo(aimEndX, aimEndY);
            ctx.stroke();
        }
        
        // Draw player body as a different colored circle
        ctx.save();
        
        // Player body - darker blue color; ghosted if dead
        const isGhostOther = (typeof otherPlayer.health === 'number' && otherPlayer.health <= 0);
        ctx.globalAlpha = isGhostOther ? 0.5 : 1.0;
        ctx.fillStyle = '#1976D2'; // Darker blue color for other players
        ctx.beginPath();
        ctx.arc(screenX, screenY, otherPlayer.radius || 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Player outline
        ctx.strokeStyle = '#0D47A1'; // Darker blue outline
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
        
        // Magenta ensnare ring while captured by Licker (same as local player)
        try {
            if (otherPlayer._ensnaredTimer && otherPlayer._ensnaredTimer > 0) {
                const t = otherPlayer._ensnarePulseT || 0;
                const pulse = 0.5 + 0.5 * (Math.sin(t * Math.PI * 2 * 1.2) * 0.5 + 0.5); // gentle pulse
                const ringR = (otherPlayer.radius || 20) + 10 + 3 * pulse;
                ctx.save();
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = '#cc66cc';
                ctx.lineWidth = 3 + 2 * pulse;
                ctx.beginPath();
                ctx.arc(screenX, screenY, ringR, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        } catch(_) {}
        
        // Hit flash effect (red overlay when damaged)
        try {
            const mgr = window.networkManager;
            if (mgr && mgr.remoteHitFlashPlayers && mgr.remoteHitFlashPlayers.has(otherPlayer.id)) {
                const flashData = mgr.remoteHitFlashPlayers.get(otherPlayer.id);
                if (flashData && flashData.hitFlash > 0) {
                    const hitFlashMax = 0.12; // Same as local player
                    const t = Math.max(0, Math.min(1, flashData.hitFlash / hitFlashMax));
                    ctx.save();
                    ctx.globalAlpha = Math.pow(t, 0.4) * 0.9; // Strong at start, fast fade
                    ctx.fillStyle = '#ff3b3b';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, otherPlayer.radius || 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        } catch(_) {}
        
        // Burning flame VFX for remote players
        try {
            if (window.networkManager && window.networkManager.remoteBurningPlayers && 
                window.networkManager.remoteBurningPlayers.has(otherPlayer.id) && 
                (otherPlayer.health == null || otherPlayer.health > 0)) {
                // Render flame effect similar to local player burning VFX
                const burnData = window.networkManager.remoteBurningPlayers.get(otherPlayer.id);
                const burnDuration = Date.now() - burnData.startTime;
                const intensity = Math.min(1.2, 1.0); // Use fixed intensity for remote players
                const baseR = (otherPlayer.radius || 20) * (0.9 + 0.6 * intensity);
                const t = burnDuration / 1000; // Convert to seconds for animation timing
                const wobble = Math.sin(t * 6) * 0.12;
                const sx0 = screenX + wobble * (otherPlayer.radius || 20) * 0.25;
                const sy0 = screenY - (otherPlayer.radius || 20) * (0.25 + 0.06 * Math.sin(t * 4 + (otherPlayer.id?.charCodeAt?.(0) || 1)));
                const grad = ctx.createRadialGradient(sx0, sy0, baseR * 0.1, sx0, sy0, baseR);
                grad.addColorStop(0, 'rgba(255, 250, 210, ' + (0.9 * intensity) + ')');
                grad.addColorStop(0.35, 'rgba(255, 200, 80, ' + (0.6 * intensity) + ')');
                grad.addColorStop(1, 'rgba(255, 120, 0, 0)');
                ctx.save();
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(sx0, sy0, baseR * (0.65 + 0.05 * Math.sin(t * 8)), baseR * (1.25 + 0.1 * Math.sin(t * 5 + 1.1)), wobble * 0.5, 0, Math.PI * 2);
                ctx.fill();
                // Small sparks
                const sparkN = 2 + Math.floor(intensity * 3);
                for (let i = 0; i < sparkN; i++) {
                    const a = (-Math.PI / 2) + (Math.random() - 0.5) * 0.6;
                    const r = (otherPlayer.radius || 20) * (0.3 + Math.random() * 0.6);
                    const px = sx0 + Math.cos(a) * r;
                    const py = sy0 + Math.sin(a) * r - (4 + Math.random() * 9);
                    ctx.globalAlpha = 0.5 * intensity;
                    ctx.fillStyle = '#ffd36b';
                    ctx.beginPath();
                    ctx.arc(px, py, 1.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            } else {
                // Cleanup any persisted remote slime state when not slowed or dead
                if (mgr && mgr.remoteSlowedPlayers) {
                    mgr.remoteSlowedPlayers.delete(otherPlayer.id);
                }
            }
        } catch(_) {}
        
        // Slime slow VFX for remote players (with falling drips)
        try {
            const mgr = window.networkManager;
            if (mgr && mgr.remoteSlowedPlayers && mgr.remoteSlowedPlayers.has(otherPlayer.id) && 
                (otherPlayer.health == null || otherPlayer.health > 0)) {
                // Pulse aura
                const t = (Date.now() % 200000) / 1000;
                const pulse = Math.sin(t * Math.PI * 2 * 0.8) * 0.5 + 0.5; // 0..1
                const a = 0.3 + 0.3 * pulse;
                ctx.save();
                ctx.globalAlpha = a;
                ctx.fillStyle = '#a8c400';
                ctx.beginPath();
                ctx.arc(screenX, screenY, (otherPlayer.radius || 20) + 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Drip integrator per remote player (world-space)
                const entry = mgr.remoteSlowedPlayers.get(otherPlayer.id) || {};
                if (!entry.drips) entry.drips = [];
                if (typeof entry.spawnTimer !== 'number') entry.spawnTimer = 0;
                const dt = (typeof window !== 'undefined' && window.state && Number.isFinite(window.state._lastDt)) ? window.state._lastDt : 0.016;
                entry.spawnTimer -= dt;
                const spawnEvery = 0.08;
                while (entry.spawnTimer <= 0) {
                    entry.spawnTimer += spawnEvery;
                    const count = 1 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        const ang = (Math.random() * Math.PI) + Math.PI * 0.5; // downward-ish
                        const offR = (otherPlayer.radius || 20) * (0.2 + Math.random() * 0.6);
                        const spawnX = otherPlayer.x + Math.cos(ang) * offR * 0.4;
                        const spawnY = otherPlayer.y + (otherPlayer.radius || 20) * 0.6 + Math.sin(ang) * 2;
                        const vy = 60 + Math.random() * 80;
                        const vx = (Math.random() * 2 - 1) * 25;
                        const life = 0.5 + Math.random() * 0.6;
                        const rad = 1.5 + Math.random() * 2.5;
                        entry.drips.push({ x: spawnX, y: spawnY, vx, vy, life, total: life, r: rad });
                    }
                }
                // Integrate and cull
                for (let i = entry.drips.length - 1; i >= 0; i--) {
                    const d = entry.drips[i];
                    d.vy += 220 * dt;
                    d.x += d.vx * dt;
                    d.y += d.vy * dt;
                    d.life -= dt;
                    if (d.life <= 0) entry.drips.splice(i, 1);
                }
                // Cap
                if (entry.drips.length > 120) entry.drips.splice(0, entry.drips.length - 120);
                // Draw
                for (let i = 0; i < entry.drips.length; i++) {
                    const d = entry.drips[i];
                    const k = Math.max(0, Math.min(1, d.life / (d.total || 0.001)));
                    const sx0 = d.x - state.cameraX;
                    const sy0 = d.y - state.cameraY;
                    ctx.save();
                    ctx.globalAlpha = 0.18 * k;
                    ctx.fillStyle = '#a8c400';
                    ctx.beginPath();
                    ctx.arc(sx0, sy0, d.r * 2.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.9 * k;
                    ctx.beginPath();
                    ctx.arc(sx0, sy0, d.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.5 * k;
                    ctx.strokeStyle = '#4a5c11';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(sx0, sy0, d.r, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                // Write back entry in map
                mgr.remoteSlowedPlayers.set(otherPlayer.id, entry);
            }
        } catch(_) {}
        
        // Health bar (still visible for clarity)
        const healthPercent = (otherPlayer.health || 100) / (otherPlayer.healthMax || 100);
        const barWidth = 30;
        const barHeight = 4;
        const barX = screenX - barWidth / 2;
        const barY = screenY - (otherPlayer.radius || 20) - 10;
        
        // Health bar background
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health bar fill
        ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FF9800' : '#F44336';
        ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Player ID indicator (first 6 chars)
        ctx.fillStyle = '#FFF';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        const playerId = otherPlayer.id ? otherPlayer.id.substring(0, 6) : 'Unknown';
        ctx.fillText(playerId, screenX, screenY + (otherPlayer.radius || 20) + 15);

        // If this other player is carrying the artifact, render it on their back
        try {
            if (isMultiplayer && window.networkManager && window.networkManager.artifactCarrierId === otherPlayer.id) {
                // Draw the artifact diamond behind the player center, offset by their aimAngle
                const rPlayer = otherPlayer.radius || 20;
                const aim = (typeof otherPlayer.aimAngle === 'number') ? otherPlayer.aimAngle : 0;
                const backAng = aim + Math.PI;
                const dist = rPlayer + 18;
                const ax = screenX + Math.cos(backAng) * dist;
                const ay = screenY + Math.sin(backAng) * dist;
                const r = 12;
                ctx.save();
                ctx.shadowColor = '#4df2ff';
                ctx.shadowBlur = 16;
                ctx.fillStyle = '#8af7ff';
                ctx.strokeStyle = '#2bc7d6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ax, ay - r);
                ctx.lineTo(ax + r, ay);
                ctx.lineTo(ax, ay + r);
                ctx.lineTo(ax - r, ay);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        } catch(_) {}
    }
}

// Send input to server
function sendPlayerInput() {
    if (!isMultiplayer || !window.networkManager.connected) return;
    // Suppress input while dead/ghost
    if (player.health <= 0) {
        // Send neutral input to keep server from moving/aiming us
        window.networkManager.sendInput({
            keys: { KeyW:false, KeyA:false, KeyS:false, KeyD:false, ShiftLeft:false, ShiftRight:false },
            mouse: { x: 0, y: 0 },
            mouseDown: false,
            aimAngle: player.aimAngle || 0
        }, { x: player.x, y: player.y });
        return;
    }
    
    // Calculate aim angle from player position to mouse position in world coordinates
    const worldMouseX = state.mouse.x + state.cameraX;
    const worldMouseY = state.mouse.y + state.cameraY;
    const aimAngle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);
    
    // Send input with current player position for client-side prediction
    window.networkManager.sendInput({
        keys: state.keys,
        mouse: state.mouse,
        mouseDown: state.mouseDown,
        aimAngle: aimAngle
    }, {
        x: player.x,
        y: player.y
    });
}

// Apply input to player for rollback re-simulation (MUST match server updatePlayerMovement exactly!)
function applyInputToPlayer(player, input) {
    const speed = 220; // Player movement speed (matches server default from player.js)
    const deltaTime = 1/60; // Fixed 60 FPS for consistent re-simulation
    
    let vx = 0, vy = 0;
    
    // Handle WASD movement (matches server logic)
    if (input.keys.KeyW) vy -= 1;
    if (input.keys.KeyS) vy += 1;
    if (input.keys.KeyA) vx -= 1;
    if (input.keys.KeyD) vx += 1;
    
    // Normalize diagonal movement (matches server)
    if (vx !== 0 && vy !== 0) {
        const mag = Math.sqrt(vx * vx + vy * vy);
        vx /= mag;
        vy /= mag;
    }
    
    // Apply speed multiplier for shift key (matches server - 2x speed when sprinting)
    let actualSpeed = input.keys.ShiftLeft || input.keys.ShiftRight ? speed * 2 : speed;
    
    // Apply boomer puke pool slow (50% speed reduction) - matches server
    if (player._svSlowed) {
        actualSpeed *= 0.5;
    }
    
    // Update position (matches server)
    player.x += vx * actualSpeed * deltaTime;
    player.y += vy * actualSpeed * deltaTime;
    
    // Apply boundary constraints (matches server)
    const boundary = window.environment ? window.environment.boundary : 1000;
    player.x = Math.max(-boundary, Math.min(boundary, player.x));
    player.y = Math.max(-boundary, Math.min(boundary, player.y));
}
// Scene switchers
window.startLevelFromLobby = function(serverObstacles, serverLevelSpawns, serverEnemies) {
    try {
        if (scene.current === 'level') return;
        // Switch to main game environment
        scene.current = 'level';
        environment = new Environment(serverObstacles);
        window.environment = environment;
        // Keep director in sync
        try { director.environment = environment; } catch(_) {}
        // Notify multiplayer server of scene change
        try {
            if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                window.networkManager.notifySceneChange('level', environment.boundary);
            }
        } catch(_) {}
        // Reset/clear state specific to level start
        // Clear enemies and npcs, chests, drops, extraction
        enemies.items.length = 0;
        if (typeof enemies.grid?.clear === 'function') enemies.grid.clear();
        npcs.items.length = 0;
        try { if (window.bossDrops && Array.isArray(window.bossDrops)) window.bossDrops.length = 0; } catch(_) {}
        // Reset gameplay flags
        state.extractionEnd = null;
        state.isFrozen = false;
        state.bossSpawned = false;
        state.artifactEverPicked = false;
        // Reset player status
        player.health = player.healthMax;
        // Reset containers dependent on environment
        chests.length = 0;
        extractionZone = null;
        // Spawn initial level content (prefer server-authoritative spawns if provided)
        let goldX = null, goldY = null;
        (function placeChestLevel(){
            if (!window.GameObjects || !window.GameObjects.Chest) return;
            const { Chest } = window.GameObjects;
            const spawns = serverLevelSpawns || (typeof window !== 'undefined' && window.__serverLevelSpawns) || null;
            if (spawns && Array.isArray(spawns.chests)) {
                for (let i = 0; i < spawns.chests.length; i++) {
                    const c = spawns.chests[i];
                    chests.push(new Chest(c.x, c.y, { variant: c.variant }));
                }
                const gold = spawns.chests.find(c => c.variant === 'gold');
                if (gold) { goldX = gold.x; goldY = gold.y; }
                // Apply NPC spawns from server
                if (Array.isArray(spawns.npcs)) {
                    for (let i = 0; i < spawns.npcs.length; i++) {
                        const n = spawns.npcs[i];
                        try {
                            if (n.type === 'NPC_A' && typeof window.NPC_A === 'function') {
                                npcs.add(new window.NPC_A(n.x, n.y));
                            } else if (n.type === 'NPC_B' && typeof window.NPC_B === 'function') {
                                npcs.add(new window.NPC_B(n.x, n.y));
                            }
                        } catch(_) {}
                    }
                }
                console.log('[Scene] Applied server-provided level spawns');
                return;
            }
            // Fallback to client deterministic placement when not connected
            const tries = 300;
            const clearance = 28;
            
            // For testing: place golden chest at a predictable location near center-ish but not exactly center
            // This makes it easy to find for testing artifacts, loot, and NPCs
            const testX = 200; // Slightly offset from center (0,0) to avoid obstacles
            const testY = 150;
            
            // Try the preferred test location first, then fall back to seeded random if needed
            console.log('[Chest Placement] Placing chests with seeded RNG');
            
            if (environment.isInsideBounds(testX, testY, clearance) && !environment.circleHitsAny(testX, testY, clearance)) {
                chests.push(new Chest(testX, testY, { variant: 'gold' }));
                goldX = testX; goldY = testY;
                console.log('[Chest Placement] Gold chest placed at preferred location:', {x: testX, y: testY});
            } else {
                // Fallback: try seeded random locations near center if preferred spot is blocked
                console.log('[Chest Placement] Preferred location blocked, using seeded fallback positioning');
                for (let i = 0; i < tries; i++) {
                    const ang = WorldRNG.randomFloat(0, Math.PI * 2);
                    const dist = 100 + WorldRNG.randomFloat(0, 300); // Stay relatively close to center
                    const nx = Math.cos(ang) * dist;
                    const ny = Math.sin(ang) * dist;
                    if (environment.isInsideBounds(nx, ny, clearance) && !environment.circleHitsAny(nx, ny, clearance)) {
                        chests.push(new Chest(nx, ny, { variant: 'gold' }));
                        goldX = nx; goldY = ny;
                        console.log('[Chest Placement] Gold chest placed at fallback location:', {x: nx, y: ny});
                        break;
                    }
                }
            }
            if (goldX != null && goldY != null) {
                // Try place a brown chest nearby the golden chest using seeded RNG
                for (let j = 0; j < 200; j++) {
                    const ang2 = WorldRNG.randomFloat(0, Math.PI * 2);
                    const d2 = 120 + WorldRNG.randomFloat(0, 180);
                    const nx2 = goldX + Math.cos(ang2) * d2;
                    const ny2 = goldY + Math.sin(ang2) * d2;
                    if (environment.isInsideBounds(nx2, ny2, clearance) && !environment.circleHitsAny(nx2, ny2, clearance)) {
                        chests.push(new Chest(nx2, ny2, { variant: 'brown' }));
                        console.log('[Chest Placement] Brown chest placed at:', {x: nx2, y: ny2});
                        break;
                    }
                }
                
                console.log('[Chest Placement] All chests placed using seed:', WorldRNG.getCurrentSeed());
                // Spawn NPCs within 500 units of the gold chest (like debugNearChest routine)
                // Spawn NPCs within 500 units of the gold chest using seeded RNG
                (function spawnNpcsNearChest(cx, cy){
                    console.log('[Level NPCs] Spawning NPCs near chest with seeded RNG');
                    
                    const maxDist = 500;
                    const npcR = 24;
                    const triesNpc = 700;
                    let placedA = false;
                    let placedB = false;
                    for (let t = 0; t < triesNpc && (!placedA || !placedB); t++) {
                        const ang = WorldRNG.randomFloat(0, Math.PI * 2);
                        const dist = WorldRNG.randomFloat(0, maxDist);
                        const tx = cx + Math.cos(ang) * dist;
                        const ty = cy + Math.sin(ang) * dist;
                        if (!environment.isInsideBounds(tx, ty, npcR)) continue;
                        if (environment.circleHitsAny(tx, ty, npcR)) continue;
                        // Avoid overlapping any chest
                        let okChest = true;
                        for (let k = 0; k < chests.length; k++) {
                            const c = chests[k]; if (!c) continue;
                            const cr = c.radius || 20;
                            const dx = tx - c.x, dy = ty - c.y;
                            if (dx*dx + dy*dy <= (cr + npcR + 6) * (cr + npcR + 6)) { okChest = false; break; }
                        }
                        if (!okChest) continue;
                        // Avoid overlapping any existing NPC
                        let okNpc = true;
                        for (let u = 0; u < npcs.items.length; u++) {
                            const n = npcs.items[u]; if (!n) continue;
                            const dxn = tx - n.x, dyn = ty - n.y;
                            if (dxn*dxn + dyn*dyn <= (npcR + (n.radius||24) + 6) * (npcR + (n.radius||24) + 6)) { okNpc = false; break; }
                        }
                        if (!okNpc) continue;
                        try {
                            if (!placedA) { npcs.add(new NPC_A(tx, ty)); placedA = true; continue; }
                            if (!placedB && window.NPC_B) { npcs.add(new window.NPC_B(tx, ty)); placedB = true; continue; }
                        } catch(_) {}
                    }
                    
                    console.log('[Level NPCs] Placed NPCs near chest:', {placedA, placedB, seed: WorldRNG.getCurrentSeed()});
                })(goldX, goldY);
            }
        })();
        
        // Now place player near the golden chest for easier testing
        (function placePlayerNearChest(){
            if (goldX === null || goldY === null) {
                // Fallback: place randomly if chest placement failed
                const tries = 400;
                const clearance = Math.max(30, player.radius + 24);
                const b = environment.boundary - clearance - 10;
                for (let i = 0; i < tries; i++) {
                    const nx = (Math.random() * 2 - 1) * b;
                    const ny = (Math.random() * 2 - 1) * b;
                    if (!environment.circleHitsAny(nx, ny, clearance) && environment.isInsideBounds(nx, ny, clearance)) {
                        player.x = nx; player.y = ny;
                        environment.spawnSafeX = nx; environment.spawnSafeY = ny; environment.spawnSafeRadius = Math.max(environment.spawnSafeRadius, clearance * 2);
                        break;
                    }
                }
            } else {
                // Place player near the golden chest for easier testing
                const tries = 200;
                const clearance = Math.max(30, player.radius + 24);
                const minDist = 80; // Close enough to easily interact
                const maxDist = 150; // But not too close to overlap
                
                for (let i = 0; i < tries; i++) {
                    const ang = Math.random() * Math.PI * 2;
                    const dist = minDist + Math.random() * (maxDist - minDist);
                    const nx = goldX + Math.cos(ang) * dist;
                    const ny = goldY + Math.sin(ang) * dist;
                    if (environment.isInsideBounds(nx, ny, clearance) && !environment.circleHitsAny(nx, ny, clearance)) {
                        player.x = nx; player.y = ny;
                        environment.spawnSafeX = nx; environment.spawnSafeY = ny; environment.spawnSafeRadius = Math.max(environment.spawnSafeRadius, clearance * 2);
                        break;
                    }
                }
            }
        })();
        // Enemies (server authoritative only; no client fallback)
        if (Array.isArray(serverEnemies) && serverEnemies.length > 0) {
            const Cls = (typeof window.Enemy === 'function') ? window.Enemy : (typeof Enemy === 'function' ? Enemy : null);
            if (Cls) {
                if (!window._enemyByServerId) window._enemyByServerId = new Map();
                window._enemyByServerId.clear();
                for (let i = 0; i < serverEnemies.length; i++) {
                    const e = serverEnemies[i]; if (!e) continue;
                    let inst = null;
                    if (e.type === 'projectile' && window.ProjectileZombie) {
                        inst = new window.ProjectileZombie(e.x, e.y);
                    } else if (e.type === 'boomer' && window.Boomer) {
                        inst = new window.Boomer(e.x, e.y);
                    } else if (e.type === 'licker' && window.Licker) {
                        inst = new window.Licker(e.x, e.y);
                    } else {
                        inst = new Cls(e.x, e.y);
                    }
                    inst._serverId = e.id;
                    inst.serverSpawned = true;
                    enemies.items.push(inst);
                    if (typeof enemies._insert === 'function') enemies._insert(inst);
                    window._enemyByServerId.set(e.id, inst);
                }
            }
            console.log('[Scene] Spawned enemies from server:', serverEnemies.length);
        }
        // Place NPCs using existing helper if present
        try { if (typeof window._relocateNPCsIfNeeded === 'function') window._relocateNPCsIfNeeded(); } catch(_) {}
        // Center camera on player in new scene
        state.cameraX = player.x - state.viewportWidth / 2;
        state.cameraY = player.y - state.viewportHeight / 2;
    } catch(e) { console.error('[Scene] Failed to start level from lobby:', e); }
};
window.returnToLobby = function(serverObstacles) {
    try {
        if (scene.current === 'lobby') return;
        scene.current = 'lobby';
        environment = new (window.EnvironmentLobby || Environment)(serverObstacles);
        window.environment = environment;
        // Keep director in sync
        try { director.environment = environment; } catch(_) {}
        // Notify multiplayer server of scene change
        try {
            if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                window.networkManager.notifySceneChange('lobby', environment.boundary);
            }
        } catch(_) {}
        // Reset world containers
        enemies.items.length = 0;
        if (typeof enemies.grid?.clear === 'function') enemies.grid.clear();
        npcs.items.length = 0;
        chests.length = 0;
        extractionZone = null;
        hereticExtractionZone = null;
        try { if (window.bossDrops && Array.isArray(window.bossDrops)) window.bossDrops.length = 0; } catch(_) {}
        // Reset player and state
        state.extractionEnd = null;
        state.isFrozen = false;
        state.bossSpawned = false;
        state.artifactEverPicked = false;
        // If converted heretic success occurred, clear conversion state and UI progress
        try {
            if (typeof window !== 'undefined') {
                window.__killThemAllLocked = false;
                window.__killThemAllProgress = 0;
                if (window.dialogueFlags) {
                    window.dialogueFlags.playerConverted = false;
                }
            }
        } catch(_) {}
        player.health = player.healthMax;
        // Place player at lobby center area
        player.x = 0; player.y = 0;
        environment.spawnSafeX = 0; environment.spawnSafeY = 0; environment.spawnSafeRadius = 200;
        // Clear stored level-entry spawn when returning to lobby
        try { player._spawnX = null; player._spawnY = null; } catch(_) {}
        state.cameraX = player.x - state.viewportWidth / 2;
        state.cameraY = player.y - state.viewportHeight / 2;
        // Respawn Merchant at upper center
        try {
            if (window.Merchant) {
                const r = 24;
                const b = environment.boundary;
                const x = 0;
                const y = -b + r + 80;
                let mx = x, my = y;
                if (!environment.isInsideBounds(mx, my, r) || environment.circleHitsAny(mx, my, r)) {
                    for (let dy = 100; dy <= 600; dy += 60) {
                        const ty = -b + r + 80 + dy;
                        if (environment.isInsideBounds(x, ty, r) && !environment.circleHitsAny(x, ty, r)) { my = ty; break; }
                    }
                }
                npcs.add(new window.Merchant(mx, my));
            }
        } catch(_) {}
        // Respawn Commander at left-center
        try {
            if (window.Commander) {
                const r = 24;
                const b = environment.boundary;
                const x = -b + r + 140;
                const y = 0;
                let cx = x, cy = y;
                if (!environment.isInsideBounds(cx, cy, r) || environment.circleHitsAny(cx, cy, r)) {
                    for (let step = 1; step <= 20; step++) {
                        const nx = x + step * 20;
                        if (environment.isInsideBounds(nx, y, r) && !environment.circleHitsAny(nx, y, r)) { cx = nx; cy = y; break; }
                    }
                }
                npcs.add(new window.Commander(cx, cy));
            }
        } catch(_) {}
        // Respawn Target Dummy using centralized spawn function
        spawnTargetDummy();
        // Respawn ambient NPCs (~10) with edge bias and clusters
        try {
            if (window.NPC_Lobby) {
                const count = 4;
                const tries = 1000;
                const r = 22;
                const placed = [];
                const isClear = (x, y) => {
                    if (!environment.isInsideBounds(x, y, r)) return false;
                    if (environment.circleHitsAny(x, y, r)) return false;
                    for (let i = 0; i < placed.length; i++) {
                        const p = placed[i];
                        const dx = x - p.x, dy = y - p.y;
                        if (dx*dx + dy*dy <= (r + p.r + 12) * (r + p.r + 12)) return false;
                    }
                    for (let i = 0; i < npcs.items.length; i++) {
                        const n = npcs.items[i]; if (!n) continue;
                        const dx = x - n.x, dy = y - n.y;
                        const rr = (r + (n.radius||24) + 12);
                        if (dx*dx + dy*dy <= rr * rr) return false;
                    }
                    return true;
                };
                const b = environment.boundary - 60;
                const inner = b - 220;
                const clusterCenters = [];
                const numClusters = 2 + Math.floor(Math.random() * 2);
                for (let c = 0; c < numClusters; c++) {
                    const edgeSide = Math.floor(Math.random() * 4);
                    let cx = 0, cy = 0;
                    if (edgeSide === 0) { cx = (Math.random()*2-1) * inner; cy = -inner; }
                    else if (edgeSide === 1) { cx = inner; cy = (Math.random()*2-1) * inner; }
                    else if (edgeSide === 2) { cx = (Math.random()*2-1) * inner; cy = inner; }
                    else { cx = -inner; cy = (Math.random()*2-1) * inner; }
                    for (let step = 0; step < 10 && (environment.circleHitsAny(cx, cy, r) || !environment.isInsideBounds(cx, cy, r)); step++) { cx *= 0.95; cy *= 0.95; }
                    clusterCenters.push({ x: cx, y: cy });
                }
                for (let k = 0; k < count; k++) {
                    let x = 0, y = 0, ok = false;
                    const useCluster = Math.random() < 0.5 && clusterCenters.length > 0;
                    if (useCluster) {
                        const cc = clusterCenters[Math.floor(Math.random() * clusterCenters.length)];
                        for (let t = 0; t < tries; t++) {
                            const ang = Math.random() * Math.PI * 2;
                            const dist = 40 + Math.random() * 160;
                            x = cc.x + Math.cos(ang) * dist;
                            y = cc.y + Math.sin(ang) * dist;
                            if (isClear(x, y)) { ok = true; break; }
                        }
                    }
                    if (!ok) {
                        const edgeSide = Math.floor(Math.random() * 4);
                        for (let t = 0; t < tries; t++) {
                            if (edgeSide === 0) { x = (Math.random()*2-1) * inner; y = -inner - Math.random()*80; }
                            else if (edgeSide === 1) { x = inner + Math.random()*80; y = (Math.random()*2-1) * inner; }
                            else if (edgeSide === 2) { x = (Math.random()*2-1) * inner; y = inner + Math.random()*80; }
                            else { x = -inner - Math.random()*80; y = (Math.random()*2-1) * inner; }
                            x = Math.max(-b+20, Math.min(b-20, x));
                            y = Math.max(-b+20, Math.min(b-20, y));
                            if (isClear(x, y)) { ok = true; break; }
                        }
                    }
                    if (ok) {
                        const n = new window.NPC_Lobby(x, y);
                        n._bark.interval *= (0.8 + Math.random()*0.7);
                        n._bark.gap *= (0.8 + Math.random()*0.7);
                        n._bark.timer = Math.random() * (n._bark.interval + n._bark.gap);
                        npcs.add(n);
                        placed.push({ x, y, r });
                    }
                }
            }
        } catch(_) {}
    } catch(e) { console.error('[Scene] Failed to return to lobby:', e); }
};
// Expose npcs for debugging or other modules
window.npcs = npcs;
// Track which NPC is currently showing the talk hint, for bark suppression
state.talkHintNpcId = null;
// Route dialogue-triggered NPC actions
window.onNpcDialogueAction = function(action, ctx){
    try {
        if (!action || typeof action !== 'object') return;
        const npcId = ctx && ctx.npcId != null ? ctx.npcId : null;
        let npc = null;
        if (npcId != null) {
            for (let i = 0; i < npcs.items.length; i++) { const n = npcs.items[i]; if (n && n.id === npcId) { npc = n; break; } }
        }
        // Fallback: nearest NPC_A
        if (!npc) {
            for (let i = 0; i < npcs.items.length; i++) { const n = npcs.items[i]; if (n && n.name === 'NPC_A') { npc = n; break; } }
        }
        if (!npc) return;
        const actRaw = String(action.action || action.value || action.state || '').toLowerCase();
        const act = (actRaw === 'default' || actRaw === 'idle') ? 'idle' : actRaw;
        if (typeof npc.switchState === 'function') {
            if (act === 'follow') npc.switchState('follow');
            else if (act === 'hostile' || act === 'attack_player') npc.switchState('hostile');
            else if (act === 'run_to_boss' || act === 'attack_boss') npc.switchState('run_to_boss');
            else npc.switchState(act);
        } else {
            npc.state = act;
        }
    } catch(_) {}
};
// Ground decal manager drawn by Environment before obstacles
const groundDecals = [];
window.drawGroundDecals = (ctx, camera, viewport) => {
        for (let i = 0; i < groundDecals.length; i++) groundDecals[i].draw(ctx, camera);
        // Cleanup expired
        for (let i = groundDecals.length - 1; i >= 0; i--) if (groundDecals[i].life <= 0) groundDecals.splice(i, 1);
};
// Bridge for enemies to place death pools underneath everything
window.enqueueGroundDecal = (vfx) => { try { groundDecals.push(vfx); } catch(e) {} };
if (DEBUG) console.log('[Main] Modules constructed');


// Global damage event queue for screen shake (works with async multiplayer damage)
window._damageEvents = [];
window.enqueueDamageEvent = function enqueueDamageEvent(damageAmount, opts = {}) {
    try {
        const amount = Number(damageAmount);
        if (!Number.isFinite(amount) || amount <= 0) return;
        if (!Array.isArray(window._damageEvents)) window._damageEvents = [];
        const evt = { amount, shakeScale: 1, source: null };
        if (opts && typeof opts === 'object') {
            if (Number.isFinite(opts.shakeScale) && opts.shakeScale > 0) evt.shakeScale = opts.shakeScale;
            if (typeof opts.source === 'string') evt.source = opts.source;
        }
        window._damageEvents.push(evt);
    } catch(_) {}
};

// Simple screen shake trigger: call with magnitude in pixels and duration seconds
// Simple screen shake trigger: call with magnitude in pixels and duration seconds
function triggerScreenShake(magnitude = 6, duration = 0.15) {
        try {
                state.shakeMag = Math.max(state.shakeMag || 0, magnitude);
                state.shakeTime = Math.max(state.shakeTime || 0, duration);
                state.shakeDur = Math.max(0.0001, duration);
                // Initialize smooth shake parameters when starting a shake burst
                if (!state._shakeInit || state.shakeTime === duration) {
                        state.shakePhase = 0;
                        // Randomize base axes so motion isn't always the same direction
                        const ang = Math.random() * Math.PI * 2;
                        state.shakeBaseAX = Math.cos(ang);
                        state.shakeBaseAY = Math.sin(ang);
                        state.shakeFreqHz = 0.5; // start with low frequency (subtle)
                        state._shakeInit = true;
                }
        } catch(_) {}
}
// Expose for other modules if needed
window.triggerScreenShake = triggerScreenShake;
// Expose state for networking damage effects (vignette, shake progress)
window.state = state;

function resizeCanvas() {
        state.viewportWidth = window.innerWidth;
        state.viewportHeight = window.innerHeight;
        canvas.width = state.viewportWidth;
        canvas.height = state.viewportHeight;
if (DEBUG) console.log('[Main] Resized canvas', { w: canvas.width, h: canvas.height });
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Expose camera/viewport getter for modules (e.g., NPC off-screen sprint checks)
window.getCamera = function() {
        try {
                return { x: state.cameraX, y: state.cameraY, width: state.viewportWidth, height: state.viewportHeight };
        } catch(_) { return null; }
};

// Spawn player at a random safe location within bounds, avoiding obstacles
// Defer player placement until environment is initialized
function placePlayerRandomly() {
        // CRITICAL: Guard against null environment during deferred initialization
        if (!environment || !worldInitialized) {
                console.log('[Main] Environment not ready, deferring player placement');
                return;
        }
        
        const tries = 400;
        const clearance = Math.max(30, player.radius + 24);
        const b = environment.boundary - clearance - 10;
        for (let i = 0; i < tries; i++) {
                const nx = (Math.random() * 2 - 1) * b;
                const ny = (Math.random() * 2 - 1) * b;
                if (!environment.circleHitsAny(nx, ny, clearance) && environment.isInsideBounds(nx, ny, clearance)) {
                        player.x = nx; player.y = ny;
                        environment.spawnSafeX = nx; environment.spawnSafeY = ny; environment.spawnSafeRadius = Math.max(environment.spawnSafeRadius, clearance * 2);
                        console.log('[Main] Player placed at:', {x: nx, y: ny});
                        break;
                }
        }
}

// Only place player if environment exists, otherwise defer
if (environment && worldInitialized) {
        placePlayerRandomly();
}

// Spawn Merchant in Lobby at upper center
function spawnLobbyMerchant() {
    try {
        if (scene.current !== 'lobby') return;
        if (!window.Merchant) return;
        if (!environment || !worldInitialized) {
            console.log('[Main] Environment not ready, deferring merchant spawn');
            return;
        }
        const r = 24;
        const b = environment.boundary;
        // Upper center: x=0, y near top boundary with margin
        const x = 0;
        const y = -b + r + 80;
        // Ensure within bounds and not inside obstacle
        let mx = x, my = y;
        if (!environment.isInsideBounds(mx, my, r) || environment.circleHitsAny(mx, my, r)) {
            // Fallback: step down until clear
            for (let dy = 100; dy <= 600; dy += 60) {
                const ty = -b + r + 80 + dy;
                if (environment.isInsideBounds(x, ty, r) && !environment.circleHitsAny(x, ty, r)) { my = ty; break; }
            }
        }
        npcs.add(new window.Merchant(mx, my));
    } catch(_) {}
}

// Call if environment is ready, otherwise defer
if (environment && worldInitialized) {
    spawnLobbyMerchant();
}

// Spawn Commander in Lobby at left-center  
function spawnLobbyCommander() {
    try {
        if (scene.current !== 'lobby') return;
        if (!window.Commander) return;
        if (!environment || !worldInitialized) {
            console.log('[Main] Environment not ready, deferring commander spawn');
            return;
        }
        const r = 24;
        const b = environment.boundary;
        // Left-center: x near left wall + margin; y = 0
        const x = -b + r + 140;
        const y = 0;
        let cx = x, cy = y;
        // If blocked, nudge inward until clear
        if (!environment.isInsideBounds(cx, cy, r) || environment.circleHitsAny(cx, cy, r)) {
            for (let step = 1; step <= 20; step++) {
                const nx = x + step * 20;
                if (environment.isInsideBounds(nx, y, r) && !environment.circleHitsAny(nx, y, r)) { cx = nx; cy = y; break; }
            }
        }
        npcs.add(new window.Commander(cx, cy));
    } catch(_) {}
}

// Call if environment is ready, otherwise defer
if (environment && worldInitialized) {
    spawnLobbyCommander();
}

// Populate lobby with ambient NPCs (~10) spaced safely, with edge bias and some clusters
;(function spawnLobbyAmbientNpcs(){
    try {
        if (scene.current !== 'lobby') return;
        if (!window.NPC_Lobby) return;
        
        // Skip client-side spawning in multiplayer mode - use server-spawned NPCs instead
        if (window.networkManager && window.networkManager.connected) {
            console.log('[Lobby NPCs] Skipping client-side spawning - using server-spawned NPCs');
            return;
        }
        
        // Use seeded RNG for synchronized NPC placement across all players
        console.log('[Lobby NPCs] Spawning ambient NPCs with seeded RNG');
        
        const count = 4;
        const tries = 1000;
        const r = 22;
        const placed = [];
        const isClear = (x, y) => {
            if (!environment.isInsideBounds(x, y, r)) return false;
            if (environment.circleHitsAny(x, y, r)) return false;
            for (let i = 0; i < placed.length; i++) {
                const p = placed[i];
                const dx = x - p.x, dy = y - p.y;
                if (dx*dx + dy*dy <= (r + p.r + 12) * (r + p.r + 12)) return false;
            }
            for (let i = 0; i < npcs.items.length; i++) {
                const n = npcs.items[i]; if (!n) continue;
                const dx = x - n.x, dy = y - n.y;
                const rr = (r + (n.radius||24) + 12);
                if (dx*dx + dy*dy <= rr * rr) return false;
            }
            return true;
        };
        const b = environment.boundary - 60;
        const inner = b - 220; // bias ring near edges
        const clusterCenters = [];
        // Seed 2-3 cluster centers on edge-biased ring
        const numClusters = 2 + WorldRNG.randomInt(0, 1);
        for (let c = 0; c < numClusters; c++) {
            const edgeSide = WorldRNG.randomInt(0, 3); // 0:top,1:right,2:bottom,3:left
            let cx = 0, cy = 0;
            if (edgeSide === 0) { cx = WorldRNG.randomFloat(-1, 1) * inner; cy = -inner; }
            else if (edgeSide === 1) { cx = inner; cy = WorldRNG.randomFloat(-1, 1) * inner; }
            else if (edgeSide === 2) { cx = WorldRNG.randomFloat(-1, 1) * inner; cy = inner; }
            else { cx = -inner; cy = WorldRNG.randomFloat(-1, 1) * inner; }
            // Nudge inward if obstructed
            for (let step = 0; step < 10 && (environment.circleHitsAny(cx, cy, r) || !environment.isInsideBounds(cx, cy, r)); step++) {
                cx *= 0.95; cy *= 0.95;
            }
            clusterCenters.push({ x: cx, y: cy });
        }
        for (let k = 0; k < count; k++) {
            let x = 0, y = 0, ok = false;
            const useCluster = WorldRNG.random() < 0.5 && clusterCenters.length > 0;
            if (useCluster) {
                // Pick a cluster, sample within a small radius
                const cc = clusterCenters[Math.floor(WorldRNG.random() * clusterCenters.length)];
                for (let t = 0; t < tries; t++) {
                    const ang = WorldRNG.randomFloat(0, Math.PI * 2);
                    const dist = 40 + WorldRNG.randomFloat(0, 160); // compact cluster
                    x = cc.x + Math.cos(ang) * dist;
                    y = cc.y + Math.sin(ang) * dist;
                    if (isClear(x, y)) { ok = true; break; }
                }
            }
            if (!ok) {
                // Edge-biased random placement: choose a side then sample inward
                const edgeSide = WorldRNG.randomInt(0, 3);
                for (let t = 0; t < tries; t++) {
                    if (edgeSide === 0) { x = WorldRNG.randomFloat(-1, 1) * inner; y = -inner - WorldRNG.randomFloat(0, 80); }
                    else if (edgeSide === 1) { x = inner + WorldRNG.randomFloat(0, 80); y = WorldRNG.randomFloat(-1, 1) * inner; }
                    else if (edgeSide === 2) { x = WorldRNG.randomFloat(-1, 1) * inner; y = inner + WorldRNG.randomFloat(0, 80); }
                    else { x = -inner - WorldRNG.randomFloat(0, 80); y = WorldRNG.randomFloat(-1, 1) * inner; }
                    // Clamp to bounds margin
                    x = Math.max(-b+20, Math.min(b-20, x));
                    y = Math.max(-b+20, Math.min(b-20, y));
                    if (isClear(x, y)) { ok = true; break; }
                }
            }
            if (ok) {
                const n = new window.NPC_Lobby(x, y);
                // Per-NPC bark timing variance using seeded RNG too
                n._bark.interval *= (0.8 + WorldRNG.randomFloat(0, 0.7));
                n._bark.gap *= (0.8 + WorldRNG.randomFloat(0, 0.7));
                n._bark.timer = WorldRNG.random() * (n._bark.interval + n._bark.gap);
                npcs.add(n);
                placed.push({ x, y, r });
            }
        }
        
        console.log('[Lobby NPCs] Spawned', placed.length, 'ambient NPCs using seed:', WorldRNG.getCurrentSeed());
    } catch(_) {}
})();

// (Removed) Client enemy spawning â€“ server authoritative only

// Spawn a neutral NPC_A away from future boss and extraction locations
;(function placeNPCs(){
    try {
        // Skip normal spawn if debug near-chest spawn is enabled (default true)
        const debugNearChest = (typeof window.DEBUG_NPC_NEAR_CHEST === 'boolean') ? window.DEBUG_NPC_NEAR_CHEST : true;
        if (debugNearChest) return;
        const minFarFromPlayer = 900; // don't spawn on top of player
        const minFarFromBoss = 2600;
        const minFarFromZone = 2600;
        const tries = 600;
        const probeR = 22;
        let nx = player.x, ny = player.y;
        for (let i = 0; i < tries; i++) {
            const b = environment.boundary - probeR - 10;
            const ang = WorldRNG.randomFloat(0, Math.PI * 2);
            const dist = minFarFromPlayer + WorldRNG.randomFloat(0, 2200);
            const tx = player.x + Math.cos(ang) * dist;
            const ty = player.y + Math.sin(ang) * dist;
            if (!environment.isInsideBounds(tx, ty, probeR)) continue;
            if (environment.circleHitsAny(tx, ty, probeR)) continue;
            // Far from extraction zone center placeholder (if exists later we will also recheck)
            let okZone = true;
            if (typeof window._plannedExtractionHint === 'object' && window._plannedExtractionHint) {
                const dxz = tx - window._plannedExtractionHint.x;
                const dyz = ty - window._plannedExtractionHint.y;
                okZone = (dxz*dxz + dyz*dyz) >= (minFarFromZone * minFarFromZone);
            }
            if (!okZone) continue;
            nx = tx; ny = ty; break;
        }
        const n = new NPC_A(nx, ny);
        npcs.add(n);
        // Reposition later if too close to actual zone/boss once they exist
        window._relocateNPCsIfNeeded = function() {
            try {
                for (let i = 0; i < npcs.items.length; i++) {
                    const npc = npcs.items[i];
                    if (!npc) continue;
                    let need = false;
                    if (window.ArtilleryWitch) {
                        for (let j = 0; j < enemies.items.length; j++) {
                            const e = enemies.items[j];
                            if (e && e.alive && (window.ArtilleryWitch && e instanceof window.ArtilleryWitch)) {
                                const dx = npc.x - e.x, dy = npc.y - e.y;
                                if (dx*dx + dy*dy < minFarFromBoss*minFarFromBoss) { need = true; break; }
                            }
                        }
                    }
                    if (!need && extractionZone) {
                        const dxz = npc.x - extractionZone.x, dyz = npc.y - extractionZone.y;
                        if (dxz*dxz + dyz*dyz < minFarFromZone*minFarFromZone) need = true;
                    }
                    if (need) {
                        // Find a new safe spot using same rules
                        for (let t = 0; t < tries; t++) {
                            const b = environment.boundary - probeR - 10;
                            const ang = Math.random() * Math.PI * 2;
                            const dist = minFarFromPlayer + Math.random() * 2200;
                            const tx = player.x + Math.cos(ang) * dist;
                            const ty = player.y + Math.sin(ang) * dist;
                            if (!environment.isInsideBounds(tx, ty, probeR)) continue;
                            if (environment.circleHitsAny(tx, ty, probeR)) continue;
                            let okB = true;
                            if (window.ArtilleryWitch) {
                                for (let j = 0; j < enemies.items.length; j++) {
                                    const e = enemies.items[j];
                                    if (e && e.alive && (window.ArtilleryWitch && e instanceof window.ArtilleryWitch)) {
                                        const dx = tx - e.x, dy = ty - e.y;
                                        if (dx*dx + dy*dy < minFarFromBoss*minFarFromBoss) { okB = false; break; }
                                    }
                                }
                            }
                            if (!okB) continue;
                            if (extractionZone) {
                                const dxz2 = tx - extractionZone.x, dyz2 = ty - extractionZone.y;
                                if (dxz2*dxz2 + dyz2*dyz2 < minFarFromZone*minFarFromZone) continue;
                            }
                            npc.x = tx; npc.y = ty; break;
                        }
                    }
                }
            } catch(_) {}
        };
    } catch(_) {}
})();

// Defer Extraction Zone creation until artifact is picked up at least once

// Spawn a chest near the player at a safe offset
const chests = [];
let extractionZone = null;
let hereticExtractionZone = null;
// Global boss drops container
window.bossDrops = window.bossDrops || [];
// Helper: ensure a dropped item is tracked by a world container for update/draw
function placeDroppedItemInWorld(item) {
    try {
        // If the item already exists in any chest's drops, no need to add
        for (let i = 0; i < chests.length; i++) {
            const c = chests[i];
            if (c && Array.isArray(c.drops) && c.drops.indexOf(item) !== -1) return;
        }
        // If it's already in the global drops list, skip
        if (Array.isArray(window.bossDrops) && window.bossDrops.indexOf(item) !== -1) return;
    } catch(_) {}
    try {
        // In multiplayer, route ground item creation through the server for replication
        if (isMultiplayer && window.networkManager && window.networkManager.connected) {
            // If this item already has a server id, just ensure it is tracked locally once
            if (item && item._serverId) {
                if (!Array.isArray(window.bossDrops)) window.bossDrops = [];
                if (window.bossDrops.indexOf(item) === -1) window.bossDrops.push(item);
                return;
            }
            // Send a server request to create this item on the ground for all players
            try {
                const label = item && (item.baseLabel || item.label) ? (item.baseLabel || item.label) : '+Stat';
                const rarityName = item && item.rarity && item.rarity.name ? item.rarity.name : 'Common';
                const color = item && item.rarity && item.rarity.color ? item.rarity.color : '#ffffff';
                const baseAngle = (item && Number.isFinite(item.vx) && Number.isFinite(item.vy)) ? Math.atan2(item.vy, item.vx) : 0;
                window.networkManager.socket.emit('inventoryDropRequest', {
                    items: [{ label, rarityName, color }],
                    x: Number(item && item.x) || 0,
                    y: Number(item && item.y) || 0,
                    baseAngle: baseAngle
                });
            } catch(_) {}
            // Do not add the local-only item; wait for server 'inventoryDropped' to add replicated items
            return;
        }
        // Single-player fallback: track locally
        if (!Array.isArray(window.bossDrops)) window.bossDrops = [];
        window.bossDrops.push(item);
    } catch(_) {}
}
// Expose getter for modules that need to inspect artifact state
window.getChests = () => chests;
// Helper: spawn boss far from player and extraction zone after artifact pickup
function spawnBossFarFromPlayerAndExtraction() {
        if (state.bossSpawned) return;
        if (!window.ArtilleryWitch) return;
        // Ensure extraction zone exists so we can respect its distance
        if (!extractionZone) return;
        try {
                // Probe radius from boss class
                const probe = new window.ArtilleryWitch(0, 0);
                const bossRadius = Math.max(78, Number.isFinite(probe.radius) ? probe.radius : 78);
                const minDistPlayer = 2600;
                const minDistZone = 2600;
                const minDistHeretic = 2600;
                const tries = 700;
                const b = environment.boundary - bossRadius - 10;
                let sx = null, sy = null;
                for (let i = 0; i < tries; i++) {
                        const nx = (Math.random() * 2 - 1) * b;
                        const ny = (Math.random() * 2 - 1) * b;
                        // Distance checks
                        const dpx = nx - player.x; const dpy = ny - player.y;
                        const dzx = nx - extractionZone.x; const dzy = ny - extractionZone.y;
                        if (dpx * dpx + dpy * dpy < minDistPlayer * minDistPlayer) continue;
                        if (dzx * dzx + dzy * dzy < minDistZone * minDistZone) continue;
                        if (hereticExtractionZone) {
                                const dhx = nx - hereticExtractionZone.x; const dhy = ny - hereticExtractionZone.y;
                                if (dhx * dhx + dhy * dhy < minDistHeretic * minDistHeretic) continue;
                        }
                        // Environment checks
                        if (!environment.isInsideBounds(nx, ny, bossRadius)) continue;
                        if (environment.circleHitsAny(nx, ny, bossRadius)) continue;
                        // Passed all checks
                        sx = nx; sy = ny; break;
                }
                // Fallback: place relative far away along a diagonal if random search failed
                if (sx == null || sy == null) {
                        sx = player.x + 3200;
                        sy = player.y + 3200;
                        if (!environment.isInsideBounds(sx, sy, bossRadius) || environment.circleHitsAny(sx, sy, bossRadius)) {
                                sx = Math.max(-b, Math.min(b, sx));
                                sy = Math.max(-b, Math.min(b, sy));
                        }
                }
                const boss = new window.ArtilleryWitch(sx, sy);
                enemies.items.push(boss);
                if (typeof enemies._insert === 'function') enemies._insert(boss);
                state.bossSpawned = true;
                if (DEBUG) console.log('[Main] Boss spawned after artifact pickup at', { x: sx, y: sy });
        } catch(e) {
                console.error('[Main] Failed to spawn boss:', e);
        }
}
;(function placeChest() {
    if (scene.current === 'lobby') return; // no level chest in lobby
        if (!window.GameObjects || !window.GameObjects.Chest) return;
        const { Chest } = window.GameObjects;
        const tries = 300;
        const minDist = 180;
        const maxDist = 420;
        const clearance = 28;
        for (let i = 0; i < tries; i++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const nx = player.x + Math.cos(ang) * dist;
                const ny = player.y + Math.sin(ang) * dist;
                if (environment.isInsideBounds(nx, ny, clearance) && !environment.circleHitsAny(nx, ny, clearance)) {
                        chests.push(new Chest(nx, ny, { variant: 'gold' }));
                        // Try place a brown chest nearby the golden chest
                        for (let j = 0; j < 200; j++) {
                                const ang2 = Math.random() * Math.PI * 2;
                                const d2 = 120 + Math.random() * 180;
                                const nx2 = nx + Math.cos(ang2) * d2;
                                const ny2 = ny + Math.sin(ang2) * d2;
                                if (environment.isInsideBounds(nx2, ny2, clearance) && !environment.circleHitsAny(nx2, ny2, clearance)) {
                                        chests.push(new Chest(nx2, ny2, { variant: 'brown' }));
                                        break;
                                }
                        }
                        // Debug: spawn NPCs within 500 units of the gold chest (after nearby chest placement)
                        (function debugSpawnNpcNearChest(cx, cy){
                                const enable = (typeof window.DEBUG_NPC_NEAR_CHEST === 'boolean') ? window.DEBUG_NPC_NEAR_CHEST : true;
                                if (!enable) return;
                                const maxDist = 500;
                                const npcR = 24;
                                const triesNpc = 700;
                                let placedA = false;
                                let placedB = false;
                                for (let t = 0; t < triesNpc && (!placedA || !placedB); t++) {
                                        const ang = Math.random() * Math.PI * 2;
                                        const dist = Math.random() * maxDist;
                                        const tx = cx + Math.cos(ang) * dist;
                                        const ty = cy + Math.sin(ang) * dist;
                                        if (!environment.isInsideBounds(tx, ty, npcR)) continue;
                                        if (environment.circleHitsAny(tx, ty, npcR)) continue;
                                        // Avoid overlapping any chest (gold or brown)
                                        let okChest = true;
                                        for (let k = 0; k < chests.length; k++) {
                                                const c = chests[k];
                                                if (!c) continue;
                                                const cr = c.radius || 20;
                                                const dx = tx - c.x, dy = ty - c.y;
                                                if (dx*dx + dy*dy <= (cr + npcR + 6) * (cr + npcR + 6)) { okChest = false; break; }
                                        }
                                        if (!okChest) continue;
                                        // Avoid overlapping any existing NPC
                                        let okNpc = true;
                                        for (let u = 0; u < npcs.items.length; u++) {
                                                const n = npcs.items[u];
                                                if (!n) continue;
                                                const dxn = tx - n.x, dyn = ty - n.y;
                                                if (dxn*dxn + dyn*dyn <= (npcR + (n.radius||24) + 6) * (npcR + (n.radius||24) + 6)) { okNpc = false; break; }
                                        }
                                        if (!okNpc) continue;
                                        try {
                                                if (!placedA) { npcs.add(new NPC_A(tx, ty)); placedA = true; continue; }
                                                if (!placedB && window.NPC_B) { npcs.add(new window.NPC_B(tx, ty)); placedB = true; continue; }
                                        } catch(_) {}
                                }
                        })(nx, ny);
                        break;
                }
        }
})();

// Initialize camera to center on player
state.cameraX = 0;
state.cameraY = 0;

// Input handlers
window.addEventListener('keydown', (e) => {
        if (e.code in state.keys) state.keys[e.code] = true;
        // Weapon hotkeys: 1-9 and 0 as 10th (disabled while dialogue open)
        const digitMap = { Digit1:0, Digit2:1, Digit3:2, Digit4:3, Digit5:4, Digit6:5, Digit7:6, Digit8:7, Digit9:8, Digit0:9 };
        if (e.code in digitMap) {
                if (dialogue && dialogue.open) {
                        // Route to dialogue: keydown highlights (press state)
                        if (typeof dialogue.onDigitDown === 'function') dialogue.onDigitDown(digitMap[e.code]);
                        // Prevent weapon switching
                        return;
                }
                projectiles.setIndex(digitMap[e.code]);
        }
        // Manual reload (R) for weapon 7
        if (e.code === 'KeyR') {
                try { if (projectiles && typeof projectiles.requestReload === 'function') projectiles.requestReload(); } catch(_) {}
        }
        if (e.code === 'KeyE') {
                state.justPressedKeyE = true;
        }
        // Invincibility toggle cheat (] key)
        if (e.code === 'BracketRight') {
                state.invincible = !state.invincible;
                console.log('[Cheat] Invincibility toggled:', state.invincible ? 'ON' : 'OFF');
                
                // In multiplayer, broadcast invincibility state to all players in the room
                try {
                        if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                window.networkManager.socket.emit('invincibilityToggle', {
                                        roomId: window.networkManager.roomId,
                                        invincible: state.invincible,
                                        fromPlayer: window.networkManager.playerId
                                });
                                console.log('[Network] Broadcasted invincibility state:', state.invincible);
                        }
                } catch(e) {
                        console.error('[Cheat] Error syncing invincibility:', e);
                }
        }
});
window.addEventListener('keyup', (e) => {
        if (e.code in state.keys) state.keys[e.code] = false;
        const digitMap = { Digit1:0, Digit2:1, Digit3:2, Digit4:3, Digit5:4, Digit6:5, Digit7:6, Digit8:7, Digit9:8, Digit0:9 };
        if (e.code in digitMap) {
                if (dialogue && dialogue.open) {
                        // Complete selection on keyup
                        if (typeof dialogue.onDigitUp === 'function') dialogue.onDigitUp(digitMap[e.code]);
                        return;
                }
        }
});
canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        state.mouse.x = e.clientX - rect.left;
        state.mouse.y = e.clientY - rect.top;
        // Maintain world-space mouse for cross-module hover checks
        try { window._mouseWorldX = state.cameraX + state.mouse.x; window._mouseWorldY = state.cameraY + state.mouse.y; } catch(_) {}
        // Forward hover to dialogue
        if (dialogue && dialogue.open && typeof dialogue.onMouseMove === 'function') {
                dialogue.onMouseMove(state.mouse.x, state.mouse.y);
        }
});
canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
        // Handle restart click when extraction overlay is visible
        if (state.extractionEnd && state.extractionButtonRect) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const b = state.extractionButtonRect;
            if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
                e.preventDefault();
                try {
                    if (state.extractionEnd.type === 'win') {
                        // Return to lobby on success
                        if (typeof window.returnToLobby === 'function') window.returnToLobby();
                    } else {
                        // On lose, also return to lobby for consistency
                        if (typeof window.returnToLobby === 'function') window.returnToLobby();
                    }
                } catch(_) {}
                return;
            }
        }
        // Handle DialogueBox close button
        {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            // First: handle choice clicks if any
            if (dialogue && dialogue.open && typeof dialogue.onMouseDown === 'function') {
                const handled = dialogue.onMouseDown(mx, my);
                if (handled) {
                    e.preventDefault();
                    return;
                }
            }
            if (dialogue && dialogue.open && typeof dialogue.tryCloseAtMouse === 'function') {
                const closed = dialogue.tryCloseAtMouse(canvas, mx, my);
                if (closed) {
                    e.preventDefault();
                    return;
                }
            }
        }
        state.mouseDown = true;
        state.justPressed = true;
        // If weapon 7 is reloading, show a persistent 'Reloading' label over player while mouse is held
        try {
            if (projectiles && projectiles.currentIndex === 6 && (projectiles.ammo7ReloadTimer || 0) > 0 && window.player) {
                const pr = window.player.radius || 26;
                window._weapon7ReloadingLabel = {
                    draw: function(ctx, cam) {
                        const sx = window.player.x - cam.x;
                        const sy = window.player.y - cam.y - (pr + 18);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.font = 'bold 18px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
                        ctx.strokeText('Reloading', sx, sy);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Reloading', sx, sy);
                        ctx.restore();
                    }
                };
            }
        } catch(_) {}
    }
});
canvas.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
                // Forward mouse up to dialogue to finalize choice selection
                {
                        const rect = canvas.getBoundingClientRect();
                        const mx = e.clientX - rect.left;
                        const my = e.clientY - rect.top;
                        if (dialogue && dialogue.open && typeof dialogue.onMouseUp === 'function') {
                                const handled = dialogue.onMouseUp(mx, my);
                                if (handled) {
                                        e.preventDefault();
                                        state.mouseDown = false;
                                        state.justReleased = true;
                                        // Hide persistent reloading label when mouse released
                                        try { window._weapon7ReloadingLabel = null; } catch(_) {}
                                        return;
                                }
                        }
                }
                state.mouseDown = false;
                state.justReleased = true;
        }
});
canvas.addEventListener('mouseleave', () => { state.mouseDown = false; });

function update(dt) {
if (DEBUG && !Number.isFinite(dt)) console.warn('[Main] Non-finite dt', dt);

        // Freeze gameplay immediately when flagged (e.g., after successful extraction)
        if (state.isFrozen) {
                state.justPressed = false;
                state.justReleased = false;
                state.justPressedKeyE = false;
                return;
        }

        // Auto-close dialogue if player walks away from engaged NPC
        (function autoCloseDialogueIfFar(){
                try {
                        if (dialogue && dialogue.open && dialogue.npcId != null) {
                                let npc = null;
                                for (let i = 0; i < npcs.items.length; i++) { if (npcs.items[i] && npcs.items[i].id === dialogue.npcId) { npc = npcs.items[i]; break; } }
                                if (!npc || !npc.alive) { dialogue.open = false; return; }
                                const dx = npc.x - player.x, dy = npc.y - player.y;
                                const talkR = (npc.radius || 24) + (player.radius || 26) + 36;
                                if (dx*dx + dy*dy > talkR * talkR) dialogue.open = false;
                        }
                } catch(_) {}
        })();

        // Update remote player hit flashes and ensnare timers in multiplayer
        if (isMultiplayer && window.networkManager) {
                try {
                        window.networkManager.updateRemoteHitFlashes(dt);
                        window.networkManager.updateRemoteEnsnareTimers(dt);
                } catch(_) {}
        }

        // Track health at frame start to detect any incoming damage this update
        const healthAtStart = player.health;
	let detectedContactDamage = false; // Track contact damage separately from health changes

        // Death handling: stop updating player when dead, run respawn timer
        if (player.health <= 0) {
                // Initialize timer on first frame of death (handles self-damage and enemy damage)
                if (state.deathTimer <= 0) {
                        state.deathTimer = 5.0;
                        // Broadcast death debug info to server/room
                        try {
                                if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                        const name = (typeof player.name === 'string' ? player.name : String(window.networkManager.playerId).substring(0,6));
                                        window.networkManager.socket.emit('playerDeath', { name, x: player.x, y: player.y });
                                        console.log(`[Client] You died: ${name} at (${player.x.toFixed(1)}, ${player.y.toFixed(1)})`);
                                } else {
                                        console.log(`[Client] You died at (${player.x.toFixed(1)}, ${player.y.toFixed(1)})`);
                                }
                        } catch(_) {}
                        // On death: clear ensnare status/effects immediately
                        try {
                                player._ensnaredTimer = 0;
                                player._ensnarePulseT = 0;
                                player._ensnaredById = null;
                                if (player._ensnaredBy && typeof player._ensnaredBy.clear === 'function') player._ensnaredBy.clear();
                        } catch(_) {}
                        // On death: clear burning DOT state and visuals
                        try {
                                player._playerDotStacks = [];
                                player._playerDotAccum = 0;
                                player._playerDotTextTimer = 0;
                                player._burnFxT = 0;
                        } catch(_) {}
                        // On death: drop carried artifact (if any) server-authoritatively like a normal drop
                        for (let i = 0; i < chests.length; i++) {
                                const art = chests[i]?.artifact;
                                if (art && art.carriedBy) {
                                        // Toss slightly outward with a small upward impulse for visibility
                                        const screenX = player.x - state.cameraX;
                                        const screenY = player.y - state.cameraY;
                                        const dxAim = state.mouse.x - screenX;
                                        const dyAim = state.mouse.y - screenY;
                                        let aimAngle = Math.atan2(dyAim, dxAim);
                                        // Add a small random spread so it isn't perfectly straight every time
                                        aimAngle += (Math.random() * 0.6 - 0.3);
                                        const horizSpeed = 140;
                                        const lift = 200; // upward impulse
                                        const artSpawnDist = (player.radius || 26) + 18 + 40; // outside the inventory drop ring
                                        const dropX = player.x + Math.cos(aimAngle) * artSpawnDist;
                                        const dropY = player.y + Math.sin(aimAngle) * artSpawnDist;
                                        const vx = Math.cos(aimAngle) * horizSpeed;
                                        const vy = Math.sin(aimAngle) * horizSpeed - lift;
                                        try {
                                                if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                        const id = chests[i]._id || (chests[i]._id = `${Math.round(chests[i].x)},${Math.round(chests[i].y)}`);
                                                        window.networkManager.socket.emit('artifactDropRequest', { chestId: id, x: dropX, y: dropY, vx, vy });
                                                } else {
                                                        art.x = dropX; art.y = dropY;
                                                        art.vx = vx; art.vy = vy;
                                                        art.onGround = false;
                                                        art.carriedBy = null;
                                                        art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                                }
                                        } catch(_) {
                                                art.x = dropX; art.y = dropY;
                                                art.vx = vx; art.vy = vy;
                                                art.onGround = false;
                                                art.carriedBy = null;
                                                art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                        }
                                }
                        }
                        // Drop equipped items from inventory server-authoritatively like normal drop
                        if (Array.isArray(player.inventory) && player.inventory.length > 0) {
                                const count = player.inventory.length;
                                // Base opposite of aim to avoid forward sector where the artifact is tossed
                                const base = (Math.atan2(state.mouse.y - (player.y - state.cameraY), state.mouse.x - (player.x - state.cameraX)) + Math.PI) || 0;
                                const itemsPayload = [];
                                for (let k = player.inventory.length - 1; k >= 0; k--) {
                                        const item = player.inventory[k];
                                        if (!item) { player.inventory.splice(k, 1); continue; }
                                        itemsPayload.push({ label: item.baseLabel || item.label, rarityName: (item.rarity && item.rarity.name) || 'Common', color: (item.rarity && item.rarity.color) || item.fill || '#ffffff' });
                                }
                                try {
                                        if (isMultiplayer && window.networkManager && window.networkManager.connected && itemsPayload.length > 0) {
                                                window.networkManager.socket.emit('inventoryDropRequest', { items: itemsPayload, x: player.x, y: player.y, baseAngle: base, speed: 200 });
                                                // Clear local inventory immediately for responsiveness
                                                player.inventory.length = 0;
                                        } else {
                                                // Offline fallback: drop locally with radial toss
                                                const spawnRing = (player.radius || 26) + 18;
                                                for (let k = count - 1; k >= 0; k--) {
                                                        const ang = base + (k * (2 * Math.PI / Math.max(1, count)));
                                                        const spd = 170 + Math.random() * 60;
                                                        const lift2 = 160;
                                                        const dropX = player.x + Math.cos(ang) * spawnRing;
                                                        const dropY = player.y + Math.sin(ang) * spawnRing;
                                                        const obj = player.inventory[k];
                                                        if (!obj) continue;
                                                        obj.x = dropX; obj.y = dropY;
                                                        obj.vx = Math.cos(ang) * spd; obj.vy = Math.sin(ang) * spd - lift2;
                                                        obj.onGround = false;
                                                        if (obj.equippedBy) obj.equippedBy = null;
                                                        if (obj && obj.statKey === 'Health' && player && typeof player.id === 'number') { obj.suppressHealForPlayerId = player.id; }
                                                        obj.pickupLockout = Math.max(0.25, obj.pickupLockout || 0.25);
                                                        placeDroppedItemInWorld(obj);
                                                }
                                                player.inventory.length = 0;
                                        }
                                } catch(_) {
                                        const spawnRing = (player.radius || 26) + 18;
                                        for (let k = count - 1; k >= 0; k--) {
                                                const ang = base + (k * (2 * Math.PI / Math.max(1, count)));
                                                const spd = 170 + Math.random() * 60;
                                                const lift2 = 160;
                                                const dropX = player.x + Math.cos(ang) * spawnRing;
                                                const dropY = player.y + Math.sin(ang) * spawnRing;
                                                const obj = player.inventory[k];
                                                if (!obj) continue;
                                                obj.x = dropX; obj.y = dropY;
                                                obj.vx = Math.cos(ang) * spd; obj.vy = Math.sin(ang) * spd - lift2;
                                                obj.onGround = false;
                                                if (obj.equippedBy) obj.equippedBy = null;
                                                if (obj && obj.statKey === 'Health' && player && typeof player.id === 'number') { obj.suppressHealForPlayerId = player.id; }
                                                obj.pickupLockout = Math.max(0.25, obj.pickupLockout || 0.25);
                                                placeDroppedItemInWorld(obj);
                                        }
                                        player.inventory.length = 0;
                                }
                        }
                }
                state.deathTimer -= dt;
                if (state.deathTimer <= 0) {
                        // Respawn player at their original level-entry spawn point (fallback to spawnSafe)
                        const rx = (typeof player._spawnX === 'number') ? player._spawnX : environment.spawnSafeX;
                        const ry = (typeof player._spawnY === 'number') ? player._spawnY : environment.spawnSafeY;
                        player.x = rx; player.y = ry;
                        player.health = player.healthMax;
                        // Broadcast respawn debug info
                        try {
                                if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                        const name = (typeof player.name === 'string' ? player.name : String(window.networkManager.playerId).substring(0,6));
                                        window.networkManager.socket.emit('playerRespawn', { name, x: player.x, y: player.y });
                                        console.log(`[Client] You respawned: ${name} at (${player.x.toFixed(1)}, ${player.y.toFixed(1)})`);
                                } else {
                                        console.log(`[Client] You respawned at (${player.x.toFixed(1)}, ${player.y.toFixed(1)})`);
                                }
                        } catch(_) {}
                        // Refill stamina on respawn and clear latches/cooldowns
                        const refillTo = Math.max(1, player?.staminaMax ?? 100);
                        if (player.stamina < refillTo) {
                                player.stamina = refillTo;
                                player.mustReleaseShift = false;
                                player.mustReleaseFire = false;
                                player.exhaustionTimer = 0;
                        }
                        // Clear all status effects on respawn
                        try {
                                // Clear ensnare state and visuals
                                player._ensnaredTimer = 0;
                                player._ensnarePulseT = 0;
                                player._ensnaredById = null;
                                if (player._ensnaredBy && typeof player._ensnaredBy.clear === 'function') player._ensnaredBy.clear();
                                // Clear slow effect and visual drips
                                player._svSlowed = false;
                                if (Array.isArray(player._slimeDrips)) player._slimeDrips.length = 0;
                                player._slimeSpawnTimer = 0;
                                player._slimePulseT = 0;
                                // Clear hit flash visuals
                                player.hitFlash = 0;
                                player.hitFlashCooldown = 0;
                        } catch(_) {}
                        state.deathTimer = 0;
                }
        } else {
                // Suppress firing while interacting with the conversion slider (when converted)
                let suppressFireForSlider = false;
                try {
                        const flags = (typeof window !== 'undefined') ? (window.dialogueFlags || {}) : {};
                        if (flags.playerConverted) {
                                const margin = 16;
                                const staminaWidth = 200;
                                const staminaHeight = 10;
                                const healthHeight = Math.round(staminaHeight * 1.5);
                                const sMax2 = Math.max(1, player?.staminaMax ?? 100);
                                const staminaTotalWidth = Math.round(staminaWidth * sMax2 / 100);
                                const sx = state.viewportWidth - margin - staminaTotalWidth;
                                const hy = margin + 18;
                                const sy = hy + healthHeight + 8;
                                const trackX = sx;
                                const trackY = sy + staminaHeight + 28;
                                const trackW = staminaTotalWidth;
                                const trackH = 12;
                                const mx = state.mouse.x, my = state.mouse.y;
                                if (state.mouseDown && mx >= trackX && mx <= trackX + trackW && my >= trackY && my <= trackY + trackH) suppressFireForSlider = true;
                        }
                } catch(_) {}
                // Flag firing state for stamina logic (used to block recharge when firing weapon 4)
                player.isFiringWeapon4 = !!(state.mouseDown && !suppressFireForSlider && projectiles.currentIndex === 3);
                player.update(dt, state.keys, environment);
                // Expose for later gating
                if (suppressFireForSlider) {
                        if (typeof window !== 'undefined') window._suppressFireForSlider = true;
                } else { if (typeof window !== 'undefined') window._suppressFireForSlider = false; }
        }

        // UI inventory interaction and fire suppression when hovering inventory
        let suppressFire = false;
        {
                const margin = 16;
                const hasArtifact = chests.some(c => c && c.artifact && c.artifact.carriedBy);
                const equippedCount = Math.max(0, Math.min(6, (player.inventory || []).length));
                const invCount = 6 + (hasArtifact ? 1 : 0);
                const slotSize = 56;
                const gap = 10;
                const totalH = invCount * slotSize + (invCount - 1) * gap;
                const startY = Math.max(margin, Math.round((state.viewportHeight - totalH) / 2));
                const x = margin;
                const mx = state.mouse.x;
                const my = state.mouse.y;
                let hoveredIndex = -1;
                for (let i = 0; i < invCount; i++) {
                        const y = startY + i * (slotSize + gap);
                        if (mx >= x && mx <= x + slotSize && my >= y && my <= y + slotSize) { hoveredIndex = i; break; }
                }
                if (hoveredIndex !== -1) suppressFire = true;
                // Helper: collect existing ground items for spacing checks
                const collectGround = () => {
                        const arr = [];
                        for (let ci = 0; ci < chests.length; ci++) {
                                const c = chests[ci];
                                if (!c) continue;
                                if (c.artifact && !c.artifact.carriedBy) arr.push({ x: c.artifact.x, y: c.artifact.y, r: c.artifact.radius || 10 });
                                if (Array.isArray(c.drops)) {
                                        for (let di = 0; di < c.drops.length; di++) {
                                                const h = c.drops[di];
                                                if (h && h.onGround && !h.equippedBy) arr.push({ x: h.x, y: h.y, r: h.radius || 12 });
                                        }
                                }
                        }
                        return arr;
                };
                const isClear = (x, y, minDist, existing) => {
                        for (let i = 0; i < existing.length; i++) {
                                const o = existing[i];
                                const dx = x - o.x, dy = y - o.y;
                                if (dx * dx + dy * dy < (minDist + (o.r || 0)) * (minDist + (o.r || 0))) return false;
                        }
                        if (environment && typeof environment.isInsideBounds === 'function') {
                                if (!environment.isInsideBounds(x, y, 12)) return false;
                        }
                        if (environment && typeof environment.circleHitsAny === 'function') {
                                if (environment.circleHitsAny(x, y, 12)) return false;
                        }
                        return true;
                };
                const findClearDrop = (prefX, prefY, minDist) => {
                        const existing = collectGround();
                        // Try preferred first
                        if (isClear(prefX, prefY, minDist, existing)) return { x: prefX, y: prefY };
                        // Spiral search
                        for (let ring = 1; ring <= 6; ring++) {
                                const rad = minDist + ring * 16;
                                const steps = 16;
                                for (let s = 0; s < steps; s++) {
                                        const ang = (s / steps) * Math.PI * 2;
                                        const nx = prefX + Math.cos(ang) * rad;
                                        const ny = prefY + Math.sin(ang) * rad;
                                        if (isClear(nx, ny, minDist, existing)) return { x: nx, y: ny };
                                }
                        }
                        // Fallback
                        return { x: prefX, y: prefY };
                };

                // If click released on inventory, process drop action and consume release
                if (state.justReleased && hoveredIndex !== -1) {
                        if (hasArtifact && hoveredIndex === invCount - 1) {
                                for (let i = 0; i < chests.length; i++) {
                                        const art = chests[i]?.artifact;
                                        if (art && art.carriedBy) {
                                                // Drop just behind the player with spacing
                                                const screenX = player.x - state.cameraX;
                                                const screenY = player.y - state.cameraY;
                                                const dxAim = state.mouse.x - screenX;
                                                const dyAim = state.mouse.y - screenY;
                                                const aimAngle = Math.atan2(dyAim, dxAim);
                                                const backAng = aimAngle + Math.PI;
                                                const dist = (player.radius || 26) + 20;
                                                const prefX = player.x + Math.cos(backAng) * dist;
                                                const prefY = player.y + Math.sin(backAng) * dist;
                                                const pos = findClearDrop(prefX, prefY, 50);
                                                try {
                                                        if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                                const id = chests[i]._id || (chests[i]._id = `${Math.round(chests[i].x)},${Math.round(chests[i].y)}`);
                                                                window.networkManager.socket.emit('artifactDropRequest', { chestId: id, x: pos.x, y: pos.y, vx: 0, vy: 0 });
                                                        } else {
                                                                art.x = pos.x; art.y = pos.y;
                                                                art.vx = 0; art.vy = 0;
                                                                art.onGround = true;
                                                                art.carriedBy = null;
                                                                art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                                        }
                                                } catch(_) {
                                                        art.x = pos.x; art.y = pos.y;
                                                        art.vx = 0; art.vy = 0;
                                                        art.onGround = true;
                                                        art.carriedBy = null;
                                                        art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                                }
                                        }
                                }
                        }
                        // Drop equipped items from inventory slots (first 6)
                        const firstEquippedIdx = 0;
                        if (hoveredIndex >= firstEquippedIdx && hoveredIndex < firstEquippedIdx + equippedCount) {
                                const idx = hoveredIndex - firstEquippedIdx;
                                const item = (player.inventory || [])[idx];
                                if (item && item.equippedBy) {
                                        // Drop at player's feet slightly forward with spacing
                                        const screenX = player.x - state.cameraX;
                                        const screenY = player.y - state.cameraY;
                                        const dxAim = state.mouse.x - screenX;
                                        const dyAim = state.mouse.y - screenY;
                                        const aimAngle = Math.atan2(dyAim, dxAim);
                                        const fwdAng = aimAngle;
                                        const dist = (player.radius || 26) + 24;
                                        const prefX = player.x + Math.cos(fwdAng) * dist;
                                        const prefY = player.y + Math.sin(fwdAng) * dist;
                                        const pos = findClearDrop(prefX, prefY, 50);
                                        // Server-authoritative drop of inventory items via hover+release
                                        try {
                                                if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                        const payload = { items: [{ label: item.baseLabel || item.label, rarityName: (item.rarity && item.rarity.name) || 'Common', color: (item.rarity && item.rarity.color) || item.fill || '#ffffff' }], x: pos.x, y: pos.y, baseAngle: fwdAng, speed: 200 };
                                                        window.networkManager.socket.emit('inventoryDropRequest', payload);
                                                        // Remove locally from inventory immediately for responsiveness
                                                        player.inventory.splice(idx, 1);
                                                } else {
                                                        item.x = pos.x; item.y = pos.y;
                                                        item.vx = 0; item.vy = 0;
                                                        item.onGround = true;
                                                        item.equippedBy = null;
                                                        if (item && item.statKey === 'Health' && player && typeof player.id === 'number') { item.suppressHealForPlayerId = player.id; }
                                                        item.pickupLockout = Math.max(0.25, item.pickupLockout || 0.25);
                                                        placeDroppedItemInWorld(item);
                                                        // Remove from inventory
                                                        player.inventory.splice(idx, 1);
                                                }
                                        } catch(_) {
                                                item.x = pos.x; item.y = pos.y;
                                                item.vx = 0; item.vy = 0;
                                                item.onGround = true;
                                                item.equippedBy = null;
                                                if (item && item.statKey === 'Health' && player && typeof player.id === 'number') { item.suppressHealForPlayerId = player.id; }
                                                item.pickupLockout = Math.max(0.25, item.pickupLockout || 0.25);
                                                placeDroppedItemInWorld(item);
                                                // Remove from inventory
                                                player.inventory.splice(idx, 1);
                                        }
                                }
                        }
                        // Consume the release so gameplay doesn't also process it
                        state.justReleased = false;
                }
        }

// Also suppress while dragging/clicking the conversion slider
try { if (window._suppressFireForSlider) suppressFire = true; } catch(_) {}
if (!state.isFrozen && !suppressFire && player.health > 0 && (state.mouseDown || state.justPressed || state.justReleased)) projectiles.tryFire(dt, player, state.mouse, { x: state.cameraX, y: state.cameraY }, { justPressed: state.justPressed, justReleased: state.justReleased, mouseDown: (state.mouseDown && !(window._suppressFireForSlider || false)) }, enemies, environment);
state.justPressed = false;
state.justReleased = false;
        if (!state.isFrozen) {
                projectiles.update(dt, environment, enemies, player);
                // Disable Search/Guard timers in lobby; only advance in level
                if (scene.current !== 'lobby') modeTimer.update(dt);
                // Update neutral NPCs
                npcs.update(dt, environment);
        }
        // Update extraction zone timer and check completion outcome
        if (dialogue && typeof dialogue.update === 'function') dialogue.update(dt);
        // Track quickbar fade timer (0..0.7) based on dialogue visibility
        if (dialogue && dialogue.open) {
                state.quickbarFade = Math.min(0.7, (state.quickbarFade || 0) + dt);
        } else {
                state.quickbarFade = 0;
        }
        if (extractionZone && extractionZone.visible && typeof extractionZone.update === 'function') {
                const wasRunning = extractionZone.started && !extractionZone.extracted;
                // Betrayed trigger: if extraction just started and NPC_A is following, set to betrayed
                try {
                        if (!wasRunning && extractionZone.started && !extractionZone.extracted && npcs && Array.isArray(npcs.items)) {
                                for (let i = 0; i < npcs.items.length; i++) {
                                        const n = npcs.items[i];
                                        if (!n || !n.alive) continue;
                                        if (n.name === 'NPC_A' && n.state === 'follow' && typeof n.switchState === 'function') {
                                                n.switchState('betrayed');
                                        }
                                }
                        }
                } catch(_) {}
                extractionZone.update(dt);
                const justCompleted = wasRunning && extractionZone.extracted;
                if (justCompleted && !state.extractionEnd) {
                        const half = (extractionZone.size || 300) / 2;
                        const inZone = (px, py) => (px >= extractionZone.x - half && px <= extractionZone.x + half && py >= extractionZone.y - half && py <= extractionZone.y + half);
                        const playerIn = inZone(player.x, player.y);
                        let artifactIn = false;
                        for (let i = 0; i < chests.length; i++) {
                                const a = chests[i]?.artifact;
                                if (!a) continue;
                                const ax = a.carriedBy ? a.carriedBy.x : a.x;
                                const ay = a.carriedBy ? a.carriedBy.y : a.y;
                                artifactIn = inZone(ax, ay);
                                break;
                        }
                        if (playerIn && artifactIn) {
                                state.extractionEnd = { type: 'win' };
                                state.isFrozen = true;
                        } else {
                                state.extractionEnd = { type: 'lose', reason: 'The artifact was left behind' };
                        }
                }
                // If timer is running and the artifact gets dropped outside the zone, reset the extraction
                if (extractionZone.started && !extractionZone.extracted) {
                        // Locate the artifact
                        let art = null;
                        for (let i = 0; i < chests.length; i++) { const a = chests[i]?.artifact; if (a) { art = a; break; } }
                        if (art && !art.carriedBy && art.onGround) {
                                const half = (extractionZone.size || 300) / 2;
                                const inZone = (px, py) => (px >= extractionZone.x - half && px <= extractionZone.x + half && py >= extractionZone.y - half && py <= extractionZone.y + half);
                                if (!inZone(art.x, art.y)) {
                                        // Reset to unopened state
                                        extractionZone.started = false;
                                        extractionZone.timeLeft = 0;
                                }
                        }
                }
        }

        // Lobby: update ReadyZone countdown
        if (scene.current === 'lobby') {
                try {
                        if (!window._readyZone && window.GameObjects && window.GameObjects.ReadyZone) {
                                window._readyZone = new window.GameObjects.ReadyZone(0, 0, 300);
                        }
                        if (window._readyZone && typeof window._readyZone.update === 'function') {
                                window._readyZone.update(dt);
                        }
                } catch(_) {}
        }
    // Update boss drops
    (function updateBossDrops(){
        const arr = window.bossDrops || [];
        for (let i = 0; i < arr.length; i++) {
            const d = arr[i];
            if (d && typeof d.update === 'function') d.update(dt, environment);
        }
        // Pick up with E handled globally via currentEquipHex logic; ensure nearest selection considers bossDrops too
    })();

    // Slow effect is now fully server-authoritative via playerSlowState events
    // The _svSlowed flag is set by the NetworkManager and used for movement prediction and VFX

        // Update Guard arrow fade based on distance to current objective
        (function updateArrowFade(){
                const fadeSeconds = 0.5;
                const rate = (fadeSeconds > 0) ? (1 / fadeSeconds) : 1;
                let desired = 0;
                if (modeTimer.currentName === 'Guard') {
                        // Determine target: unopened gold chest, else artifact on ground
                        const goldChest = chests.find(c => c && c.variant === 'gold');
                        let target = null;
                        if (goldChest) {
                                if (!goldChest.opened) target = { x: goldChest.x, y: goldChest.y };
                                else if (goldChest.artifact && !goldChest.artifact.carriedBy) target = { x: goldChest.artifact.x, y: goldChest.artifact.y };
                        }
                        if (target) {
                                const dx = target.x - player.x;
                                const dy = target.y - player.y;
                                const dist = Math.hypot(dx, dy);
                                desired = (dist > 500) ? 1 : 0;
                        }
                }
                // Lerp arrowAlpha toward desired at rate per second
                if (state.arrowAlpha < desired) {
                        state.arrowAlpha = Math.min(desired, state.arrowAlpha + rate * dt);
                } else if (state.arrowAlpha > desired) {
                        state.arrowAlpha = Math.max(desired, state.arrowAlpha - rate * dt);
                }
        })();

        // Each frame: determine the nearest equippable hex for tooltip purposes
        (function updateEquipHint() {
                // Suppress equip hint when inventory is full
                if (Array.isArray(player.inventory) && player.inventory.length >= 6) {
                        window.currentEquipHex = null;
                        return;
                }
                let best = null; let bestDist = Infinity;
                for (let i = 0; i < chests.length; i++) {
                        const c = chests[i];
                        if (!c || !Array.isArray(c.drops)) continue;
                        for (let j = 0; j < c.drops.length; j++) {
                                const h = c.drops[j];
                                if (!h || h.equippedBy || !h.onGround || typeof h.canEquip !== 'function') continue;
                                if (!h.canEquip(player)) continue;
                                const dx = h.x - player.x, dy = h.y - player.y; const d2 = dx * dx + dy * dy;
                                if (d2 < bestDist) { bestDist = d2; best = h; }
                        }
                }
                // Consider boss drops as well
                if (Array.isArray(window.bossDrops)) {
                        for (let k = 0; k < window.bossDrops.length; k++) {
                                const h = window.bossDrops[k];
                                if (!h || h.equippedBy || !h.onGround || typeof h.canEquip !== 'function') continue;
                                if (!h.canEquip(player)) continue;
                                const dx = h.x - player.x, dy = h.y - player.y; const d2 = dx * dx + dy * dy;
                                if (d2 < bestDist) { bestDist = d2; best = h; }
                        }
                }
                window.currentEquipHex = best;
        })();

        // Toggle extraction zone visibility based on artifact carried status
        (function updateExtractionVisibility(){
        if (scene.current !== 'level') { extractionZone = null; hereticExtractionZone = null; return; }
                const hasArtifact = chests.some(c => c && c.artifact && c.artifact.carriedBy);
                // Create once when artifact has ever been picked (even if dropped later)
                if (!extractionZone && (hasArtifact || state.artifactEverPicked)) {
                        // Late-create extraction zone if not created earlier for any reason
                        try {
                                const { ExtractionZone } = window.GameObjects || {};
                                if (ExtractionZone) {
                                        const gold = chests.find(c => c && c.variant === 'gold');
                                        const refX = gold ? gold.x : player.x;
                                        const refY = gold ? gold.y : player.y;
                                        const minFar = 2800;
                                        const maxFar = 5200;
                                        const tries = 400;
                                        const clearance = 160;
                                        for (let i = 0; i < tries && !extractionZone; i++) {
                                                const ang = WorldRNG.randomFloat(0, Math.PI * 2);
                                                const dist = WorldRNG.randomFloat(minFar, maxFar);
                                                const nx = refX + Math.cos(ang) * dist;
                                                const ny = refY + Math.sin(ang) * dist;
                                                if (environment.isInsideBounds(nx, ny, clearance) && !environment.circleHitsAny(nx, ny, clearance)) {
                                                        extractionZone = new ExtractionZone(nx, ny, 300);
                                                        // Expose a planned hint early so NPC spawner can avoid it pre-creation
                                                        window._plannedExtractionHint = { x: nx, y: ny };
                                                        break;
                                                }
                                        }
                                        if (!extractionZone) {
                                                extractionZone = new ExtractionZone(refX + 3600, refY + 3600, 300);
                                                window._plannedExtractionHint = { x: refX + 3600, y: refY + 3600 };
                                        }
                                }
                        } catch(e) {}
                }
                // Create Heretic zone once player is converted and has picked artifact at least once
                if (!hereticExtractionZone && (hasArtifact || state.artifactEverPicked)) {
                        try {
                                const converted = (typeof window !== 'undefined' && window.__killThemAllLocked === true);
                                const { HereticExtractionZone } = window.GameObjects || {};
                                if (converted && HereticExtractionZone) {
                                        const gold = chests.find(c => c && c.variant === 'gold');
                                        const refX = gold ? gold.x : player.x;
                                        const refY = gold ? gold.y : player.y;
                                        // Try to place roughly opposite the green zone for clarity
                                        let baseX = refX + 3800, baseY = refY - 3600;
                                        let placed = false;
                                        const minFarFromGreen = 2200;
                                        const minFarFromGold = 2200;
                                        const minFarFromBoss = 2200;
                                        for (let i = 0; i < 600 && !placed; i++) {
                                                const ang = WorldRNG.randomFloat(0, Math.PI * 2);
                                                const dist = WorldRNG.randomFloat(3000, 5400);
                                                const nx = baseX + Math.cos(ang) * dist;
                                                const ny = baseY + Math.sin(ang) * dist;
                                                if (!environment.isInsideBounds(nx, ny, 160)) continue;
                                                if (environment.circleHitsAny(nx, ny, 160)) continue;
                                                // keep it far from normal extraction if exists
                                                let ok = true;
                                                if (extractionZone) {
                                                        const dx = nx - extractionZone.x; const dy = ny - extractionZone.y;
                                                        ok = ok && (dx*dx + dy*dy) >= (minFarFromGreen * minFarFromGreen);
                                                }
                                                // keep it far from golden chest
                                                if (ok && gold) {
                                                        const dxg = nx - gold.x; const dyg = ny - gold.y;
                                                        ok = ok && (dxg*dxg + dyg*dyg) >= (minFarFromGold * minFarFromGold);
                                                }
                                                // keep it far from boss if already spawned
                                                if (ok) {
                                                        try {
                                                                for (let ei = 0; ei < enemies.items.length; ei++) {
                                                                        const e = enemies.items[ei];
                                                                        if (e && e.alive && window.ArtilleryWitch && (e instanceof window.ArtilleryWitch)) {
                                                                                const dxb = nx - e.x; const dyb = ny - e.y;
                                                                                if (dxb*dxb + dyb*dyb < (minFarFromBoss * minFarFromBoss)) { ok = false; break; }
                                                                        }
                                                                }
                                                        } catch(_) {}
                                                }
                                                if (ok) {
                                                        hereticExtractionZone = new HereticExtractionZone(nx, ny, 300);
                                                        placed = true;
                                                }
                                        }
                                        if (!placed) {
                                                // Fallback: offset far in another quadrant but still enforce basic spacing where possible
                                                let fx = refX - 3600, fy = refY - 3600;
                                                if (extractionZone) {
                                                        const dx = fx - extractionZone.x; const dy = fy - extractionZone.y;
                                                        if (dx*dx + dy*dy < (minFarFromGreen * minFarFromGreen)) { fx += 2600; fy -= 2600; }
                                                }
                                                if (gold) {
                                                        const dxg = fx - gold.x; const dyg = fy - gold.y;
                                                        if (dxg*dxg + dyg*dyg < (minFarFromGold * minFarFromGold)) { fx -= 2400; fy += 2000; }
                                                }
                                                hereticExtractionZone = new HereticExtractionZone(fx, fy, 300);
                                        }
                                }
                        } catch(_) {}
                }
                // Visible states
                if (extractionZone) {
                        let artifactInZone = false;
                        if (!extractionZone.extracted) {
                                for (let i = 0; i < chests.length; i++) {
                                        const a = chests[i]?.artifact;
                                        if (!a) continue;
                                        const half = (extractionZone.size || 300) / 2;
                                        const ax = a.carriedBy ? a.carriedBy.x : a.x;
                                        const ay = a.carriedBy ? a.carriedBy.y : a.y;
                                        if (ax >= extractionZone.x - half && ax <= extractionZone.x + half && ay >= extractionZone.y - half && ay <= extractionZone.y + half) {
                                                artifactInZone = true;
                                        }
                                        break;
                                }
                        }
                        extractionZone.visible = (!extractionZone.extracted) && ((!!hasArtifact) || artifactInZone);
                        // If converted and holding the artifact, hide the normal extraction zone
                        try { if (typeof window !== 'undefined' && window.__killThemAllLocked === true && hasArtifact) extractionZone.visible = false; } catch(_) {}
                }
                if (hereticExtractionZone) {
                        let artifactInZone = false;
                        if (!hereticExtractionZone.extracted) {
                                for (let i = 0; i < chests.length; i++) {
                                        const a = chests[i]?.artifact;
                                        if (!a) continue;
                                        const half = (hereticExtractionZone.size || 300) / 2;
                                        const ax = a.carriedBy ? a.carriedBy.x : a.x;
                                        const ay = a.carriedBy ? a.carriedBy.y : a.y;
                                        if (ax >= hereticExtractionZone.x - half && ax <= hereticExtractionZone.x + half && ay >= hereticExtractionZone.y - half && ay <= hereticExtractionZone.y + half) {
                                                artifactInZone = true;
                                        }
                                        break;
                                }
                        }
                        const converted = (typeof window !== 'undefined' && window.__killThemAllLocked === true);
                        hereticExtractionZone.visible = (!hereticExtractionZone.extracted) && converted && ((!!hasArtifact) || artifactInZone);
                }
                // Now that we know the actual zone positions, relocate NPCs if necessary once
                try { if (typeof window._relocateNPCsIfNeeded === 'function') window._relocateNPCsIfNeeded(); } catch(_) {}
        })();

        // Spawn the boss once, after the artifact is first picked up, far from player and extraction zone
        (function maybeSpawnBossAfterArtifact(){
                if (!state.bossSpawned && state.artifactEverPicked && window.ArtilleryWitch) {
                        // Defer until extraction zone exists so we can respect its distance
                        if (extractionZone) spawnBossFarFromPlayerAndExtraction();
                        // After spawn, ensure NPC not near boss
                        try { if (typeof window._relocateNPCsIfNeeded === 'function') window._relocateNPCsIfNeeded(); } catch(_) {}
                }
        })();

        // Capture E press for this frame
        const __pressedE = state.justPressedKeyE === true;
        // If E was pressed, pick the single closest interaction (chest, artifact or hex) and perform it
        if (state.justPressedKeyE) {
                let best = null;
                let bestDist = Infinity;
                let bestArtifact = null;
                let bestArtifactDist = Infinity;
                // In lobby: consider ReadyZone interaction only
                if (scene.current === 'lobby') {
                        // Create a single ReadyZone at lobby center if not present (draw/update later in render)
                        if (!window._readyZone && window.GameObjects && window.GameObjects.ReadyZone) {
                                window._readyZone = new window.GameObjects.ReadyZone(0, 0, 300);
                        }
                        if (window._readyZone && window._readyZone._isPlayerNearCenter && window._readyZone._isPlayerNearCenter(player)) {
                                best = { type: 'ready' };
                                bestDist = 0;
                        }
                }
                // Candidate: talk to nearest NPC in range
                (function considerNpcTalk(){
                        try {
                                let nearest = null; let d2best = Infinity;
                                for (let i = 0; i < npcs.items.length; i++) {
                                        const n = npcs.items[i];
                                        if (!n || !n.alive) continue;
                                        // Disable talking if NPC has disabled talk (e.g., after following)
                                        if (n._disableTalk || n.state === 'follow') continue;
                                        const dx = n.x - player.x, dy = n.y - player.y;
                                        const d2 = dx*dx + dy*dy;
                                        let talkR = (n.radius || 24) + (player.radius || 26) + 36;
                                        // Merchant (and others) can specify a talk range boost
                                        try { if (typeof n.talkRangeBoost === 'number') talkR += Math.max(0, n.talkRangeBoost); } catch(_) {}
                                        if (d2 <= talkR * talkR && d2 < d2best) { d2best = d2; nearest = n; }
                                }
                                if (nearest && nearest.state !== 'follow') {
                                        best = { type: 'npc_talk', npc: nearest };
                                        bestDist = d2best;
                                }
                        } catch(_) {}
                })();
                for (let i = 0; i < chests.length; i++) {
                        const c = chests[i];
                        // Candidate: chest open (when in proximity and not opened)
                        if (c && !c.opened) {
                                const dxC = c.x - player.x;
                                const dyC = c.y - player.y;
                                const canOpenDist = Math.pow((player.radius || 18) + (c.radius || 20) + 30, 2);
                                const d2C = dxC * dxC + dyC * dyC;
                                if (d2C <= canOpenDist) {
                                        if (d2C < bestDist) { bestDist = d2C; best = { type: 'chest', chest: c }; }
                                }
                        }
                        // Candidate: artifact pickup (track separately to prioritize)
                        if (c && c.artifact && !c.artifact.carriedBy && typeof c.artifact.canPickUp === 'function') {
                                if (c.artifact.canPickUp(player)) {
                                        const dx = c.artifact.x - player.x;
                                        const dy = c.artifact.y - player.y;
                                        const d2 = dx * dx + dy * dy;
                                        if (d2 < bestArtifactDist) { bestArtifactDist = d2; bestArtifact = { type: 'artifact', chest: c, item: c.artifact }; }
                                        // Also consider for general best to keep behavior consistent if no higher-priority candidate appears
                                        if (d2 < bestDist) { bestDist = d2; best = { type: 'artifact', chest: c, item: c.artifact }; }
                                }
                        }
                        // Candidates: hex stats equip
                        if (c && Array.isArray(c.drops)) {
                                for (let j = 0; j < c.drops.length; j++) {
                                        const h = c.drops[j];
                                        if (h && !h.equippedBy && typeof h.canEquip === 'function' && h.canEquip(player)) {
                                                const dx = h.x - player.x;
                                                const dy = h.y - player.y;
                                                const d2 = dx * dx + dy * dy;
                                                if (d2 < bestDist) { bestDist = d2; best = { type: 'hex', chest: c, item: h, index: j }; }
                                        }
                                }
                        }
                }
                // Consider extraction zone start interaction
                if (extractionZone && extractionZone.visible && !extractionZone.started && !extractionZone.extracted) {
                        if (extractionZone._isPlayerNearCenter && extractionZone._isPlayerNearCenter(player)) {
                                const dx = extractionZone.x - player.x;
                                const dy = extractionZone.y - player.y;
                                const d2 = dx * dx + dy * dy;
                                if (d2 < bestDist) { bestDist = d2; best = { type: 'extract' }; }
                        }
                }
                // Consider heretic extraction zone start interaction
                if (hereticExtractionZone && hereticExtractionZone.visible && !hereticExtractionZone.started && !hereticExtractionZone.extracted) {
                        if (hereticExtractionZone._isPlayerNearCenter && hereticExtractionZone._isPlayerNearCenter(player)) {
                                const dx = hereticExtractionZone.x - player.x;
                                const dy = hereticExtractionZone.y - player.y;
                                const d2 = dx * dx + dy * dy;
                                if (d2 < bestDist) { bestDist = d2; best = { type: 'extract_heretic' }; }
                        }
                }
                // Candidates: boss loot hexes
                if (Array.isArray(window.bossDrops)) {
                        for (let j = 0; j < window.bossDrops.length; j++) {
                                const h = window.bossDrops[j];
                                if (h && !h.equippedBy && typeof h.canEquip === 'function' && h.canEquip(player)) {
                                        const dx = h.x - player.x;
                                        const dy = h.y - player.y;
                                        const d2 = dx * dx + dy * dy;
                                        if (d2 < bestDist) { bestDist = d2; best = { type: 'hex_boss', item: h, index: j }; }
                                }
                        }
                }
                // Prioritize artifact pickup over other interactions if available
                if (bestArtifact) {
                        best = bestArtifact;
                }
                if (best) {
                        if (best.type === 'chest') {
                                best.chest.tryOpen(player, true);
                        }
                        if (best.type === 'artifact') {
                                // Server-authoritative pickup when in multiplayer
                                try {
                                        if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                const id = best.chest._id || (best.chest._id = `${Math.round(best.chest.x)},${Math.round(best.chest.y)}`);
                                                window.networkManager.socket.emit('artifactPickupRequest', { chestId: id });
                                        } else {
                                                best.item.carriedBy = player;
                                                state.artifactEverPicked = true;
                                        }
                                } catch(_) {
                                        best.item.carriedBy = player;
                                        state.artifactEverPicked = true;
                                }
                        } else if (best.type === 'hex' || best.type === 'hex_boss') {
                                // Treat all hex items, including Health, as inventory items
                                if (!Array.isArray(player.inventory)) player.inventory = [];
                                if (player.inventory.length < 6) {
                                        // Server-authoritative pickup of ground items if they have a server id
                                        try {
                                                if (isMultiplayer && window.networkManager && window.networkManager.connected && best.item && best.item._serverId) {
                                                        window.networkManager.socket.emit('inventoryPickupRequest', { id: best.item._serverId });
                                                        // Locally remove from ground immediately for responsiveness
                                                        if (Array.isArray(window.bossDrops)) {
                                                                const idx = window.bossDrops.indexOf(best.item);
                                                                if (idx !== -1) window.bossDrops.splice(idx, 1);
                                                        }
                                                }
                                        } catch(_) {}
                                        best.item.equippedBy = player;
                                        player.inventory.push(best.item);
                                        // Remove from bossDrops if applicable (non-networked)
                                        if (best.type === 'hex_boss' && Array.isArray(window.bossDrops)) {
                                                const idx = window.bossDrops.indexOf(best.item);
                                                if (idx !== -1) window.bossDrops.splice(idx, 1);
                                        }
                                } else {
                                        // Inventory full: show message over item
                                        if (typeof best.item === 'object') best.item.fullMsgTimer = 1.5;
                                }
                        } else if (best.type === 'extract') {
                                if (extractionZone) {
                                        // Converted players cannot start the normal extraction; they must use the heretic zone
                                        let convertedBlock = false; try { convertedBlock = (typeof window !== 'undefined' && window.__killThemAllLocked === true); } catch(_) {}
                                        if (!convertedBlock) {
                                                // Trigger NPC betrayal immediately if following when extraction is started by E
                                                try {
                                                        if (npcs && Array.isArray(npcs.items)) {
                                                                for (let i = 0; i < npcs.items.length; i++) {
                                                                        const n = npcs.items[i];
                                                                        if (n && n.alive && n.name === 'NPC_A' && n.state === 'follow' && typeof n.switchState === 'function') {
                                                                                n.switchState('betrayed');
                                                                        }
                                                                }
                                                        }
                                                } catch(_) {}
                                                extractionZone.tryStart(player, true);
                                        }
                                }
                        } else if (best.type === 'extract_heretic') {
                                if (hereticExtractionZone) {
                                        hereticExtractionZone.tryStart(player, true);
                                }
                        } else if (best.type === 'ready') {
                                if (window._readyZone && typeof window._readyZone.tryStart === 'function') window._readyZone.tryStart(player, true);
                        } else if (best.type === 'npc_talk') {
                                (async () => {
                                        try {
                                                const npcName = best.npc?.name || 'NPC';
                                                const key = String(npcName).replace(/\s+/g, '_');
                                                const data = await dialogueLoader.load(key, 'start');
                                                if (dialogue && typeof dialogue.openWith === 'function') {
                                                        const payload = (data && data.nodes)
                                                                ? { title: data.title || npcName, nodes: data.nodes, start: data.start || 'start' }
                                                                : { title: data?.title || npcName, lines: Array.isArray(data?.lines) ? data.lines : [] };
                                                        dialogue.openWith(payload);
                                                        try { dialogue.npcId = best.npc?.id; } catch(_) { dialogue.npcId = null; }
                                                }
                                        } catch(e) {
                                                console.error('[Main] Failed to open NPC dialogue:', e);
                                                if (dialogue && typeof dialogue.openWith === 'function') {
                                                        const npcName = best.npc?.name || 'NPC';
                                                        dialogue.openWith({ title: npcName, lines: ["..."] });
                                                        try { dialogue.npcId = best.npc?.id; } catch(_) { dialogue.npcId = null; }
                                                }
                                        }
                                })();
                        }
                }
                state.justPressedKeyE = false;
        }
        // Chest interactions and updates (use cached E press)
        for (let i = 0; i < chests.length; i++) {
                const c = chests[i];
            if (!c.opened) c.tryOpen(player, __pressedE);
                // Determine player's current aim angle for carrying offset
                const screenX = player.x - state.cameraX;
                const screenY = player.y - state.cameraY;
                const dxAim = state.mouse.x - screenX;
                const dyAim = state.mouse.y - screenY;
                const aimAngle = Math.atan2(dyAim, dxAim);
                c.update(dt, environment, player, aimAngle);
                // (E press is handled globally for closest item; nothing else to do here)
        }
        state.justPressedKeyE = false;

        // Handle inventory click interactions (drop carried items)
        if (state.justPressed) {
                const margin = 16;
                const hasArtifact = chests.some(c => c && c.artifact && c.artifact.carriedBy);
                const invCount = hasArtifact ? 7 : 6;
                const slotSize = 56;
                const gap = 10;
                const totalH = invCount * slotSize + (invCount - 1) * gap;
                const startY = Math.max(margin, Math.round((state.viewportHeight - totalH) / 2));
                const x = margin;
                const mx = state.mouse.x;
                const my = state.mouse.y;
                let clickedIndex = -1;
                for (let i = 0; i < invCount; i++) {
                        const y = startY + i * (slotSize + gap);
                        if (mx >= x && mx <= x + slotSize && my >= y && my <= y + slotSize) { clickedIndex = i; break; }
                }
                if (clickedIndex !== -1) {
                        // If clicked the artifact slot and we are carrying it, drop it
                        if (hasArtifact && clickedIndex === invCount - 1) {
                                for (let i = 0; i < chests.length; i++) {
                                        const art = chests[i]?.artifact;
                                        if (art && art.carriedBy) {
                                                // Drop just behind the player
                                                const screenX = player.x - state.cameraX;
                                                const screenY = player.y - state.cameraY;
                                                const dxAim = state.mouse.x - screenX;
                                                const dyAim = state.mouse.y - screenY;
                                                const aimAngle = Math.atan2(dyAim, dxAim);
                                                const backAng = aimAngle + Math.PI;
                                                const dist = (player.radius || 26) + 20;
                                                const dropX = player.x + Math.cos(backAng) * dist;
                                                const dropY = player.y + Math.sin(backAng) * dist;
                                                try {
                                                        if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                                const id = chests[i]._id || (chests[i]._id = `${Math.round(chests[i].x)},${Math.round(chests[i].y)}`);
                                                                window.networkManager.socket.emit('artifactDropRequest', { chestId: id, x: dropX, y: dropY, vx: 0, vy: 0 });
                                                        } else {
                                                                art.x = dropX; art.y = dropY;
                                                                art.vx = 0; art.vy = 0;
                                                                art.onGround = true;
                                                                art.carriedBy = null;
                                                                art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                                        }
                                                } catch(_) {
                                                        art.x = dropX; art.y = dropY;
                                                        art.vx = 0; art.vy = 0;
                                                        art.onGround = true;
                                                        art.carriedBy = null;
                                                        art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                                }
                                        }
                                }
                        }
                        // If clicked within first 6 slots: drop an inventory item onto the ground via server
                        const firstEquippedIdx = 0;
                        const equippedCount = Math.max(0, Math.min(6, (player.inventory || []).length));
                        if (clickedIndex >= firstEquippedIdx && clickedIndex < firstEquippedIdx + equippedCount) {
                                const idx = clickedIndex - firstEquippedIdx;
                                const item = (player.inventory || [])[idx];
                                if (item && item.equippedBy) {
                                        // Compute a clear forward drop point and radial spread
                                        const screenX = player.x - state.cameraX;
                                        const screenY = player.y - state.cameraY;
                                        const dxAim = state.mouse.x - screenX;
                                        const dyAim = state.mouse.y - screenY;
                                        const aimAngle = Math.atan2(dyAim, dxAim);
                                        const fwdAng = aimAngle;
                                        const dist = (player.radius || 26) + 24;
                                        const dropX = player.x + Math.cos(fwdAng) * dist;
                                        const dropY = player.y + Math.sin(fwdAng) * dist;
                                        // Server-authoritative drop of inventory items
                                        try {
                                                if (isMultiplayer && window.networkManager && window.networkManager.connected) {
                                                        const payload = { items: [{ label: item.baseLabel || item.label, rarityName: (item.rarity && item.rarity.name) || 'Common', color: (item.rarity && item.rarity.color) || item.fill || '#ffffff' }], x: dropX, y: dropY, baseAngle: fwdAng, speed: 200 };
                                                        window.networkManager.socket.emit('inventoryDropRequest', payload);
                                                        // Remove locally from inventory immediately for responsiveness
                                                        player.inventory.splice(idx, 1);
                                                } else {
                                                        // Offline fallback: local drop
                                                        item.x = dropX; item.y = dropY;
                                                        item.vx = Math.cos(fwdAng) * 200; item.vy = Math.sin(fwdAng) * 200 - 160;
                                                        item.onGround = false;
                                                        item.equippedBy = null;
                                                        if (item && item.statKey === 'Health' && player && typeof player.id === 'number') { item.suppressHealForPlayerId = player.id; }
                                                        item.pickupLockout = Math.max(0.25, item.pickupLockout || 0.25);
                                                        placeDroppedItemInWorld(item);
                                                        player.inventory.splice(idx, 1);
                                                }
                                        } catch(_) {
                                                item.x = dropX; item.y = dropY;
                                                item.vx = Math.cos(fwdAng) * 200; item.vy = Math.sin(fwdAng) * 200 - 160;
                                                item.onGround = false;
                                                item.equippedBy = null;
                                                if (item && item.statKey === 'Health' && player && typeof player.id === 'number') { item.suppressHealForPlayerId = player.id; }
                                                item.pickupLockout = Math.max(0.25, item.pickupLockout || 0.25);
                                                placeDroppedItemInWorld(item);
                                                player.inventory.splice(idx, 1);
                                        }
                                }
                        }
                }
        }

        // Player damage-over-time when overlapping enemies: 10 HP/sec per enemy contact (only when alive)
	// In multiplayer, detect damage for effects but don't modify health (server handles it)
        if (!state.isFrozen && player.health > 0) {
                // Expand search to account for special reach enemies (e.g., Licker at 75)
                const searchRadius = Math.max(player.radius + 34, player.radius + 75);
                const nearby = enemies.queryCircle ? enemies.queryCircle(player.x, player.y, searchRadius) : enemies.items || [];
		let totalDamage = 0;
		let lickerDamage = 0;
                for (let i = 0; i < nearby.length; i++) {
                        const e = nearby[i];
                        if (!e || !e.alive) continue;
                        const dx = e.x - player.x;
                        const dy = e.y - player.y;
                        let inRange = false;
                        try {
                                if (window.Licker && e instanceof window.Licker) {
                                        // Only damage if THIS Licker currently ensnares the player
                                        const tThis = (player._ensnaredBy && player._ensnaredBy.get) ? (player._ensnaredBy.get(e.id) || 0) : 0;
                                        const ensnarerOk = tThis > 0;
                                        if (ensnarerOk) {
                                                const lr = player.radius + 75;
                                                inRange = (dx * dx + dy * dy) <= (lr * lr);
                                        } else {
                                                inRange = false;
                                        }
                                } else {
                                        const sumR = (e.radius || 0) + player.radius;
                                        inRange = (dx * dx + dy * dy) <= (sumR * sumR);
                                }
                        } catch(_) {
                                const sumR = (e.radius || 0) + player.radius;
                                inRange = (dx * dx + dy * dy) <= (sumR * sumR);
                        }
			if (inRange) {
				const dmg = 10 * dt;
				totalDamage += dmg;
				if (window.Licker && e instanceof window.Licker) {
					lickerDamage += dmg;
					console.log('🦎 [Licker] Client contact damage:', dmg.toFixed(3), 'ensnared:', (player._ensnaredBy && player._ensnaredBy.get(e.id)) || 0);
				}
			}
                }
		if (totalDamage > 0) {
                        // Apply armor reduction (cap 50%)
			let reduced = totalDamage;
			try {
				if (player && typeof player.getArmorReductionFactor === 'function') {
					const red = Math.max(0, Math.min(0.5, player.getArmorReductionFactor()));
					reduced = totalDamage * (1 - red);
				}
			} catch(_) {}

			if (!state.invincible && !isMultiplayer) {
				player.health -= reduced;
			}

			// Trigger ALL visual effects for both single and multiplayer
			// Hit flash
                        try {
                                if (player && typeof player.hitFlashMax === 'number') {
                                        const canFlash = (!player.hitFlash || player.hitFlash <= 0) && (!player.hitFlashCooldown || player.hitFlashCooldown <= 0);
                                        if (canFlash) {
                                                player.hitFlash = player.hitFlashMax;
                                                player.hitFlashCooldown = player.hitFlashGap || 0.07;
                                        }
                                }
                        } catch(_) {}
			
			// Queue damage event for shake/vignette processing (processed in update loop)
			let shakeScale = 1;
			if (totalDamage > 0) {
				const armorFactor = reduced / totalDamage;
				const reducedLicker = lickerDamage * armorFactor;
				const reducedOther = Math.max(0, reduced - reducedLicker);
				const shakeEnergy = reducedOther + reducedLicker * 2;
				if (reduced > 0 && shakeEnergy > 0) {
					shakeScale = shakeEnergy / reduced;
				}
			}
			const source = lickerDamage > 0 ? 'contact-licker' : 'contact';
			window.enqueueDamageEvent(reduced, { source, shakeScale });
			
			// Mark that we detected contact damage
			detectedContactDamage = true;
			
			// Death handling (single player only - MP handled by server)
			if (!isMultiplayer && player.health < 0) {
                                player.health = 0;
                                state.deathTimer = 5.0; // seconds until respawn
                                // On death by enemy contact, drop carried artifact with a small toss
                                for (let i = 0; i < chests.length; i++) {
                                        const art = chests[i]?.artifact;
                                        if (art && art.carriedBy) {
                                                const screenX = player.x - state.cameraX;
                                                const screenY = player.y - state.cameraY;
                                                const dxAim = state.mouse.x - screenX;
                                                const dyAim = state.mouse.y - screenY;
                                                let aimAngle = Math.atan2(dyAim, dxAim);
                                                aimAngle += (Math.random() * 0.6 - 0.3);
                                                const horizSpeed = 140;
                                                const lift = 200;
                                                const artSpawnDist = (player.radius || 26) + 18 + 40; // outside the inventory drop ring
                                                art.x = player.x + Math.cos(aimAngle) * artSpawnDist;
                                                art.y = player.y + Math.sin(aimAngle) * artSpawnDist;
                                                art.vx = Math.cos(aimAngle) * horizSpeed;
                                                art.vy = Math.sin(aimAngle) * horizSpeed - lift;
                                                art.onGround = false;
                                                art.carriedBy = null;
                                                art.pickupLockout = Math.max(0.15, art.pickupLockout || 0.15);
                                        }
                                }
                                // Also drop equipped items from inventory with a radial toss and offset ring to avoid overlap with artifact
                                if (Array.isArray(player.inventory) && player.inventory.length > 0) {
                                        const count = player.inventory.length;
                                        // Base opposite of aim to avoid forward sector where the artifact is tossed
                                        const base = (Math.atan2(state.mouse.y - (player.y - state.cameraY), state.mouse.x - (player.x - state.cameraX)) + Math.PI) || 0;
                                        const spawnRing = (player.radius || 26) + 18;
                                        for (let k = player.inventory.length - 1; k >= 0; k--) {
                                                const item = player.inventory[k];
                                                if (!item) { player.inventory.splice(k, 1); continue; }
                                                const ang = base + (k * (2 * Math.PI / Math.max(1, count)));
                                                const spd = 170 + Math.random() * 60;
                                                const lift2 = 160;
                                                item.x = player.x + Math.cos(ang) * spawnRing;
                                                item.y = player.y + Math.sin(ang) * spawnRing;
                                                item.vx = Math.cos(ang) * spd;
                                                item.vy = Math.sin(ang) * spd - lift2;
                                                item.onGround = false;
                                                if (item.equippedBy) item.equippedBy = null;
                                                if (item && item.statKey === 'Health' && player && typeof player.id === 'number') { item.suppressHealForPlayerId = player.id; }
                                                item.pickupLockout = Math.max(0.25, item.pickupLockout || 0.25);
                                                placeDroppedItemInWorld(item);
                                                player.inventory.splice(k, 1);
                                        }
                                }
                        }
                }
        }

        // Bullet vs enemy hits
        // Do a simple check: if bullet overlaps enemy, apply damage and remove bullet
        // Optimized: use spatial hash query and cap cone VFX per bullet to prevent spikes
        if (!state.isFrozen) for (let i = projectiles.items.length - 1; i >= 0; i--) {
                const b = projectiles.items[i];
                // Reset behind-enemy flag each frame
                b.sortBehindThisFrame = false;
                // Enemy-owned bullet vs player collision
                try {
                        const ownerIsEnemy = !!(b && (
                                b._serverEnemyBullet === true ||
                                (b.owner && b.owner.isEnemy === true) ||
                                (b.owner && window.Enemy && (b.owner instanceof window.Enemy))
                        ));
                        const ownerIsHostileNpcB = !!(b && b.owner && b.owner.name === 'NPC_B' && b.owner.state === 'hostile');
                        if ((ownerIsEnemy || ownerIsHostileNpcB) && !b.isCone && !b.noDamage && (!b.deathYellowCircle || b.allowMidflightPlayerHit)) {
                                if (player && player.health > 0) {
                                        const dxp = player.x - b.x;
                                        const dyp = player.y - b.y;
                                        const rr = (player.radius || 26) + (b.radius || 0);
                                        if (dxp * dxp + dyp * dyp <= rr * rr) {
                                                let damage = (typeof b.damage === 'number') ? b.damage : 18;
                                                // Apply damage only in single-player; server handles damage in multiplayer
                                                if (!state.invincible && !isMultiplayer) {
                                                        player.health -= damage;
                                                }
                                                if (player.health < 0) player.health = 0;
                                                // Trigger brief red hit flash and cooldown like contact damage (keep VFX in multiplayer)
                                                try {
                                                        if (player && typeof player.hitFlashMax === 'number') {
                                                                const canFlash = (!player.hitFlash || player.hitFlash <= 0) && (!player.hitFlashCooldown || player.hitFlashCooldown <= 0);
                                                                if (canFlash) {
                                                                        player.hitFlash = player.hitFlashMax;
                                                                        player.hitFlashCooldown = player.hitFlashGap || 0.07;
                                                                }
                                                        }
                                                } catch(_) {}
                                                // Impact VFX for feedback
                                                try { if (window.ImpactVfx) projectiles.impacts.push(new window.ImpactVfx(b.x, b.y, b.color, -b.vx, -b.vy)); } catch(_) {}
                                                // If this projectile is allowed to explode on player impact (Fast Ball), trigger its explosion
                                                if (b.allowMidflightPlayerHit && window.ExplosionVfx) {
                                                        try {
                                                                projectiles.impacts.push(new window.ExplosionVfx(b.x, b.y, '#ffae00'));
                                                        } catch(_) {}
                                                }
                                                projectiles.items.splice(i, 1);
                                                continue;
                                        }
                                }
                                // Also resolve hits against otherPlayers for observer clients so bullets don't pass through remotely
                                try {
                                        if (Array.isArray(otherPlayers) && otherPlayers.length > 0) {
                                                for (let opi = 0; opi < otherPlayers.length; opi++) {
                                                        const op = otherPlayers[opi]; if (!op) continue;
                                                        const dxrp = op.x - b.x;
                                                        const dyrp = op.y - b.y;
                                                        const rrp = (op.radius || 20) + (b.radius || 0);
                                                        if (dxrp * dxrp + dyrp * dyrp <= rrp * rrp) {
                                                                // Feedback only on observers: impact VFX and remove bullet
                                                                try { if (window.ImpactVfx) projectiles.impacts.push(new window.ImpactVfx(b.x, b.y, b.color, -b.vx, -b.vy)); } catch(_) {}
                                                                projectiles.items.splice(i, 1);
                                                                // Restart outer loop index since we removed current bullet
                                                                continue;
                                                        }
                                                }
                                        }
                                } catch(_) {}
                        }
                        // Enemy (or hostile NPC_B) cone vs player collision: apply DOT and flame VFX like weapon 4
                        if ((ownerIsEnemy || ownerIsHostileNpcB) && b.isCone && !b.noDamage) {
                                if (player && player.health > 0 && !b._playerHit) {
                                        const px = player.x - b.x;
                                        const py = player.y - b.y;
                                        const range = (b.coneRange || 0) + (player.radius || 26);
                                        if (px * px + py * py <= range * range) {
                                                let dAng = Math.atan2(py, px) - (b.angle || 0);
                                                while (dAng > Math.PI) dAng -= Math.PI * 2;
                                                while (dAng < -Math.PI) dAng += Math.PI * 2;
                                                if (Math.abs(dAng) <= (b.coneHalf || 0)) {
                                                        // Apply a DOT similar to enemy DOT handling (weapon 4 effect)
                                                        try {
                                                                if (!player._playerDotStacks) player._playerDotStacks = [];
                                                                const wasBurning = player._playerDotStacks.length > 0;
                                                                // Push a DOT stack: DPS ~5 for 3.2s (halved)
                                                                player._playerDotStacks.push({ dps: 2.5, timeLeft: 3.2 });
                                                                // Burning state changes are now handled by player DOT processing for all sources
                                                        } catch(_) {}
                                                        // No direct heavy hit; DOT handles damage over time
                                                        // Feedback
                                                        try { if (window.ImpactVfx) projectiles.impacts.push(new window.ImpactVfx(player.x, player.y, b.color || '#ff4d4d', -b.vx, -b.vy)); } catch(_) {}
                                                        b._playerHit = true;
                                                }
                                        }
                                }
                        }
                } catch(_) {}
                // Limit candidate enemies using spatial grid when available
                const maxEnemyR = 34; // account for larger variants (e.g., PukeZombie radius 32)
                const searchR = b.isCone ? (b.coneRange + maxEnemyR) : (b.radius + maxEnemyR);
                const candidates = (typeof enemies.queryCircle === 'function') ? enemies.queryCircle(b.x, b.y, searchR) : enemies.items;
                // Include hostile NPC_B as valid targets for player bullets
                let targets = Array.isArray(candidates) ? candidates.slice() : (enemies.items || []);
                try {
                        const list = window?.npcs?.items || [];
                        for (let ni = 0; ni < list.length; ni++) {
                                const n = list[ni];
                                if (!n || !n.alive) continue;
                                if (n.name === 'NPC_B' && n.state === 'hostile') targets.push(n);
                        }
                } catch(_) {}
                // Throttle cone slash VFX per bullet
                let coneVfxCount = 0;
                for (let j = 0; j < targets.length; j++) {
                        const e = targets[j];
                        if (!e || !e.alive) continue;
                        if (b.isCone) {
                                const ex = e.x - b.x;
                                const ey = e.y - b.y;
                                const range = b.coneRange + e.radius;
                                if (ex * ex + ey * ey <= range * range) {
                                        let dAng = Math.atan2(ey, ex) - b.angle;
                                        while (dAng > Math.PI) dAng -= Math.PI * 2;
                                        while (dAng < -Math.PI) dAng += Math.PI * 2;
                                        if (Math.abs(dAng) <= b.coneHalf) {
                                                if (!b.alreadyHitEnemyIds.has(e.id)) {
                                                        if ((b.sourceWeaponIndex === 3) && typeof e.applyDot === 'function') {
                                                                let dotBonus = 0;
                                                                try { dotBonus = Math.max(0, player?.getDotAttackPowerBonus?.() || 0); } catch(_) {}
                                                                
                                                                // For server-synchronized target dummies, send DOT to server
                                                                if (e.serverSync && window.networkManager) {
                                                                    console.log('[TargetDummy] Sending DOT to server:', { dps: 5 + dotBonus, duration: 3 });
                                                                    window.networkManager.sendTargetDummyDot(5 + dotBonus, 3);
                                                                } else {
                                                                    // For regular enemies, apply DOT locally
                                                                    e.applyDot(5 + dotBonus, 3, { owner: player });
                                                                }
                                                        } else {
                                                                let dmg = (typeof b.damage === 'number') ? b.damage : 20;
                                                                try { dmg += Math.max(0, b.owner?.getTotalAttackPowerFlat?.() || 0); } catch(_) {}
                                                                try {
                                                                        const owner = b.owner;
                                                                        const cc = Math.max(0, Math.min(1, owner?.critChance ?? 0));
                                                                        const cm = Math.max(1, owner?.critDamageMultiplier ?? 1);
                                                                        const isCrit = Math.random() < cc;
                                                                        if (isCrit) dmg *= cm;
                                                                        // Only create client-side damage text for non-server-synchronized enemies
                                                                        // Server-synchronized entities (like target dummies) get authoritative damage text from server
                                                                        if (window.enqueueDamageText && !e.serverSync) {
                                                                                window.enqueueDamageText({ x: e.x, y: e.y - (e.radius || 26) - 6, text: Math.round(dmg).toString(), crit: isCrit, color: isCrit ? '#ffd36b' : '#ffffff', vy: -80, life: 0.8 });
                                                                        }
                                                                } catch(_) {}
                                                                e.applyDamage(dmg);
                                                        }
                                                        b.alreadyHitEnemyIds.add(e.id);
                                                        if (b.sourceWeaponIndex !== 3 && window.SlashVfx && coneVfxCount < 4) {
                                                                projectiles.impacts.push(new window.SlashVfx(e.x, e.y, b.angle, '#ff4d4d'));
                                                                coneVfxCount++;
                                                        }
                                                }
                                        }
                                }
                        } else {
                                const dx = e.x - b.x;
                                const dy = e.y - b.y;
                                const r = e.radius + b.radius;
                                if (!b.noDamage && !b.ignoreEnemies && dx * dx + dy * dy <= r * r) {
                                        // On any enemy hit this frame, render behind enemies
                                        b.sortBehindThisFrame = true;
                                        const isPiercingWeapon5 = (b.sourceWeaponIndex === 4);
                                        const alreadyHit = b.alreadyHitEnemyIds && b.alreadyHitEnemyIds.has(e.id);
                                        if (!alreadyHit) {
                                                let hitDamage = (typeof b.damage === 'number') ? b.damage : 20;
                                                try { hitDamage += Math.max(0, b.owner?.getTotalAttackPowerFlat?.() || 0); } catch(_) {}
									let isCrit = false;
									try {
                                                        const owner = b.owner;
                                                        const cc = Math.max(0, Math.min(1, owner?.critChance ?? 0));
                                                        const cm = Math.max(1, owner?.critDamageMultiplier ?? 1);
											isCrit = Math.random() < cc;
                                                        if (isCrit) hitDamage *= cm;
                                                        // Only create client-side damage text for non-server-synchronized enemies
                                                        // Server-synchronized entities (like target dummies) get authoritative damage text from server
                                                        if (window.enqueueDamageText && !e.serverSync) {
                                                                window.enqueueDamageText({ x: e.x, y: e.y - (e.radius || 26) - 6, text: Math.round(hitDamage).toString(), crit: isCrit, color: isCrit ? '#ffd36b' : '#ffffff', vy: -80, life: 0.8 });
                                                        }
									} catch(_) {}
                                                e.applyDamage(hitDamage, { x: b.x, y: b.y, dirX: b.vx, dirY: b.vy });
                                                // Relay projectile hit so remote clients apply damage
                                                try {
											if (window.networkManager && e._serverId && b.owner === window.player && !b.isCone) {
                                                                if (window.DEBUG_WEAPON9_SYNC && b.sourceWeaponIndex === 8) {
															try { console.log('[Weapon9][Send] projectileHit to server:', { id: e._serverId, damage: Math.round(hitDamage), crit: isCrit, x: b.x, y: b.y }); } catch(_) {}
                                                                }
                                                                window.networkManager.socket.emit('projectileHit', { id: e._serverId, damage: Math.round(hitDamage), crit: isCrit, x: b.x, y: b.y });
											} else if (window.DEBUG_WEAPON9_SYNC && b.sourceWeaponIndex === 8) {
													// Help diagnose why send did not occur for weapon 9
													try {
														console.log('[Weapon9][Send][Skip] not emitting projectileHit', {
															hasNetworkManager: !!window.networkManager,
															hasServerId: !!(e && e._serverId),
															isOwner: b.owner === window.player,
															isCone: !!b.isCone
														});
													} catch(_) {}
                                                        }
                                                } catch(_) {}
                                                // Queue knockback over 0.2s for projectiles that define it (weapon 3)
                                                if (b.knockback && b.knockback > 0 && typeof e.applyKnockback === 'function') {
                                                        const spd = Math.hypot(b.vx, b.vy) || 1;
                                                        const ux = b.vx / spd;
                                                        const uy = b.vy / spd;
                                                        e.applyKnockback(ux, uy, b.knockback, 0.2);
                                                }
                                                if (b.alreadyHitEnemyIds) b.alreadyHitEnemyIds.add(e.id);
                                                // Spawn VFX at impact (safely)
                                                if (window.ImpactVfx) {
                                                        projectiles.impacts.push(new window.ImpactVfx(b.x, b.y, b.color, -b.vx, -b.vy, { scale: b.impactScale || 1 }));
                                                }
                                        }
                                        if (!isPiercingWeapon5) {
                                                projectiles.items.splice(i, 1);
                                                break;
                                        }
                                }
                        }
                }
        }

        if (!state.isFrozen) {
                enemies.update(dt);
				// AI director drives enemy movement after physics updates and before draw
				// In multiplayer, movement is server-authoritative; do not run local AI
				if (!isMultiplayer && director && typeof director.update === 'function') director.update(dt);
                // Apply (inactive-by-default) enemy net smoothing when server becomes authoritative
                if (window.networkManager && typeof window.networkManager.applyEnemyNetSmoothing === 'function') {
                    window.networkManager.applyEnemyNetSmoothing(dt);
                }
                // Update ground decals (blood pools) so they can spread and fade
                for (let i = groundDecals.length - 1; i >= 0; i--) {
                        const d = groundDecals[i];
                        if (d && typeof d.update === 'function') d.update(dt);
                        if (!d || d.life <= 0) groundDecals.splice(i, 1);
                }
        }

        // Camera follow with deadzone and smoothing
        const cx = state.viewportWidth / 2;
        const cy = state.viewportHeight / 2;
        const deadzoneX = state.viewportWidth * 0.15;
        const deadzoneY = state.viewportHeight * 0.15;
        const left = cx - deadzoneX;
        const right = cx + deadzoneX;
        const top = cy - deadzoneY;
        const bottom = cy + deadzoneY;

        const screenX = player.x - state.cameraX;
        const screenY = player.y - state.cameraY;

        let targetCamX = state.cameraX;
        let targetCamY = state.cameraY;

        if (screenX < left) targetCamX = player.x - left;
        else if (screenX > right) targetCamX = player.x - right;

        if (screenY < top) targetCamY = player.y - top;
        else if (screenY > bottom) targetCamY = player.y - bottom;

        const followStrength = 10;
        const t = 1 - Math.exp(-followStrength * dt);
        state.cameraX += (targetCamX - state.cameraX) * t;
        state.cameraY += (targetCamY - state.cameraY) * t;

	// Process queued damage events (from both local contact damage and server-synced damage)
	if (window._damageEvents && window._damageEvents.length > 0) {
		// Sum all damage this frame
		let totalDamageRaw = 0;
		let totalShakeDamage = 0;
		const eventCount = window._damageEvents.length;
		for (let i = 0; i < eventCount; i++) {
			const evt = window._damageEvents[i];
			if (evt == null) continue;
			let amount = 0;
			let shakeScale = 1;
			if (typeof evt === 'number') {
				amount = evt;
			} else {
				amount = Number(evt.amount);
				if (!Number.isFinite(amount)) amount = 0;
				if (Number.isFinite(evt.shakeScale) && evt.shakeScale > 0) shakeScale = evt.shakeScale;
			}
			if (amount <= 0) continue;
			totalDamageRaw += amount;
			totalShakeDamage += amount * shakeScale;
		}
		window._damageEvents.length = 0; // Clear queue
		if (totalDamageRaw > 0) {
			console.log('💥 [Main] PROCESSING DAMAGE QUEUE - Events:', eventCount, 'Total damage:', totalDamageRaw.toFixed(3), 'Shake-weighted:', totalShakeDamage.toFixed(3));
			
		// Trigger shake and vignette (using same formula as original game)
		const frac = Math.min(1, totalDamageRaw / Math.max(1, player.healthMax || 100));
		state.damageStreakTime = Math.min(2.0, (state.damageStreakTime || 0) + dt);
		state.shakeProgress = Math.min(1, (state.shakeProgress || 0) + dt / 0.6);
		const ampEase = Math.max(0, Math.min(1, state.shakeProgress));
		const easedAmp = ampEase * ampEase;
		
		// Calculate shake magnitude using exponential moving average of recent damage
		const emaTau = 0.5; const alpha = 1 - Math.exp(-dt / emaTau);
		state._recentDamageEma = (1 - alpha) * (state._recentDamageEma || 0) + alpha * totalShakeDamage;
		const recentNorm = Math.max(0, Math.min(1, (state._recentDamageEma || 0) / 30));
		const impulseNorm = Math.max(0, Math.min(1, totalShakeDamage / 30));
		const impulseBoost = Math.sqrt(impulseNorm);
		const damageIntensity = Math.min(1, recentNorm * 0.6 + impulseBoost * 0.8);
		// Original game formula: builds from 5 to 17 pixels as damage intensity grows
		const baseMag = 5 + 12 * damageIntensity;
		const mag = baseMag * (0.45 + 0.55 * easedAmp);
		triggerScreenShake(mag, 0.12);
		
		// Vignette
		const target = 0.3 + 0.7 * Math.max(frac, damageIntensity);
		const rateUp = 8;
		state.vignette += (target - (state.vignette || 0)) * Math.min(1, dt * rateUp);
		state.vignette = Math.max(0, Math.min(1, state.vignette));
		}
	} else {
		// No damage this frame - decay effects
		state.damageStreakTime = Math.max(0, (state.damageStreakTime || 0) - dt * 2);
		state.shakeProgress = Math.max(0, (state.shakeProgress || 0) - dt / 0.3);
		if (state.damageStreakTime < 0.01) state.damageStreakTime = 0;
		if (state.vignette > 0) {
			const rateDown = 3.2;
			state.vignette = Math.max(0, (state.vignette || 0) - rateDown * dt);
		}
	}
        // Decay shake timer
        if (state.shakeTime > 0) {
                state.shakeTime -= dt;
                if (state.shakeTime < 0) state.shakeTime = 0;
        }
        // Update shake frequency to ramp with progress (low -> higher)
        if (state.shakeTime > 0) {
                const ampEase = Math.max(0, Math.min(1, state.shakeProgress || 0));
                // Frequency from 0.6Hz up to ~3Hz as progress increases
                const targetHz = 0.6 + 2.4 * ampEase;
                // Smoothly lerp frequency to avoid abrupt jumps
                state.shakeFreqHz += (targetHz - (state.shakeFreqHz || 0)) * Math.min(1, dt * 8);
                // Advance phase
                state.shakePhase += (state.shakeFreqHz || 0) * dt * Math.PI * 2;
        }

        if (hereticExtractionZone && hereticExtractionZone.visible && typeof hereticExtractionZone.update === 'function') {
                const wasRunningH = hereticExtractionZone.started && !hereticExtractionZone.extracted;
                hereticExtractionZone.update(dt);
                const justCompletedH = wasRunningH && hereticExtractionZone.extracted;
                if (justCompletedH && !state.extractionEnd) {
                        const half = (hereticExtractionZone.size || 300) / 2;
                        const inZone = (px, py) => (px >= hereticExtractionZone.x - half && px <= hereticExtractionZone.x + half && py >= hereticExtractionZone.y - half && py <= hereticExtractionZone.y + half);
                        const playerIn = inZone(player.x, player.y);
                        let artifactIn = false;
                        for (let i = 0; i < chests.length; i++) {
                                const a = chests[i]?.artifact;
                                if (!a) continue;
                                const ax = a.carriedBy ? a.carriedBy.x : a.x;
                                const ay = a.carriedBy ? a.carriedBy.y : a.y;
                                artifactIn = inZone(ax, ay);
                                break;
                        }
                        if (playerIn && artifactIn) {
                                state.extractionEnd = { type: 'heretic', reason: 'The heretics have stolen the artifact' };
                                state.isFrozen = true;
                        } else {
                                state.extractionEnd = { type: 'lose', reason: 'The artifact was left behind' };
                        }
                }
                if (hereticExtractionZone.started && !hereticExtractionZone.extracted) {
                        let art = null;
                        for (let i = 0; i < chests.length; i++) { const a = chests[i]?.artifact; if (a) { art = a; break; } }
                        if (art && !art.carriedBy && art.onGround) {
                                const half = (hereticExtractionZone.size || 300) / 2;
                                const inZone = (px, py) => (px >= hereticExtractionZone.x - half && px <= hereticExtractionZone.x + half && py >= hereticExtractionZone.y - half && py <= hereticExtractionZone.y + half);
                                if (!inZone(art.x, art.y)) {
                                        hereticExtractionZone.started = false;
                                        hereticExtractionZone.timeLeft = 0;
                                }
                        }
                }
        }
}

function render() {
        // CRITICAL: Guard against null objects during initialization
        if (!environment || !player || !enemies || !npcs || !ui) {
                console.log('[Main] Render deferred - core objects not ready:', {
                        environment: !!environment,
                        player: !!player, 
                        enemies: !!enemies,
                        npcs: !!npcs,
                        ui: !!ui
                });
                return;
        }

        // Apply screen shake only to world layers (not UI)
        let __shakeApplied = false;
        if (state.shakeTime > 0 && state.shakeDur > 0) {
                if (state.shakeTime > 0.08) {
                        console.log('🎥 [Render] SHAKE ACTIVE - shakeTime:', state.shakeTime.toFixed(3), 'shakeDur:', state.shakeDur.toFixed(3), 'shakeMag:', state.shakeMag.toFixed(2));
                }
                const k = Math.max(0, Math.min(1, state.shakeTime / state.shakeDur));
                // Combine time-based ease and amplitude progress so shake starts soft and grows
                const timeEase = k * k; // ease-out for shake life
                const ampEase = Math.max(0, Math.min(1, state.shakeProgress || 0));
                const intensity = state.shakeMag * timeEase * (0.45 + 0.55 * ampEase);

                // SIMPLIFIED: Direct sine/cosine with full magnitude

		// Use original game's shake offset formula with rotating base axes
		const s = Math.sin(state.shakePhase || 0);
		const c = Math.cos((state.shakePhase || 0) * 0.8 + 1.1);
		const ax = state.shakeBaseAX || 1;
		const ay = state.shakeBaseAY || 0;
		const ox = (ax * s + ay * c * 0.6) * intensity;
		const oy = (ay * s + ax * c * 0.6) * intensity;
                ctx.save();
                ctx.translate(ox, oy);
                __shakeApplied = true;
        }

        environment.draw(ctx, { x: state.cameraX, y: state.cameraY }, { width: state.viewportWidth, height: state.viewportHeight });

        // Behind-enemy bullet layer
        if (typeof projectiles.drawLayer === 'function') projectiles.drawLayer(ctx, { x: state.cameraX, y: state.cameraY }, true);
        enemies.draw(ctx, { x: state.cameraX, y: state.cameraY }, { width: state.viewportWidth, height: state.viewportHeight });
        // Draw neutral NPCs between enemies and player so player renders on top
        // Instead of drawing barks here, collect NPCs and draw barks at the very end over overlays
        window._npcBarkList = [];
        npcs.draw(ctx, { x: state.cameraX, y: state.cameraY }, { width: state.viewportWidth, height: state.viewportHeight });
        // Refresh world mouse (in case camera moved this frame)
        try { window._mouseWorldX = state.cameraX + state.mouse.x; window._mouseWorldY = state.cameraY + state.mouse.y; } catch(_) {}
        // Aim override for weapon 7: snap facing to hovered target if present, else red priority
        let __aimX = state.mouse.x, __aimY = state.mouse.y;
        try {
                if (projectiles && projectiles.currentIndex === 6 && state.mouseDown && enemies && typeof enemies.queryCircle === 'function') {
                        const radius = 350;
                        let active = null;
                        // Mouse-over wins
                        try {
                                const mwx = state.cameraX + state.mouse.x;
                                const mwy = state.cameraY + state.mouse.y;
                                const hover = enemies.queryCircle(mwx, mwy, 80) || [];
                                let bestHoverD2 = Infinity;
                                for (let i = 0; i < hover.length; i++) {
                                        const e = hover[i];
                                        if (!e || !e.alive) continue;
                                        const dxm = mwx - e.x;
                                        const dym = mwy - e.y;
                                        const rad = (e.radius || 24);
                                        const d2m = dxm * dxm + dym * dym;
                                        if (d2m <= rad * rad && d2m < bestHoverD2) { bestHoverD2 = d2m; active = e; }
                                }
                        } catch(_) {}
                        // Fallback: closest to player within radius
                        if (!active) {
                                const list = enemies.queryCircle(player.x, player.y, radius) || [];
                                let bestD2 = Infinity;
                                for (let i = 0; i < list.length; i++) {
                                        const e = list[i];
                                        if (!e || !e.alive) continue;
                                        const dx = e.x - player.x;
                                        const dy = e.y - player.y;
                                        const d2 = dx * dx + dy * dy;
                                        if (d2 < bestD2) { bestD2 = d2; active = e; }
                                }
                        }
                        if (active) { __aimX = active.x - state.cameraX; __aimY = active.y - state.cameraY; }
                }
        } catch(_) {}
        player.draw(ctx, { x: state.cameraX, y: state.cameraY }, { x: __aimX, y: __aimY });
        // Draw persistent weapon 7 reloading label if present
        try {
                if (projectiles && projectiles.currentIndex === 6 && state.mouseDown && (projectiles.ammo7ReloadTimer || 0) > 0 && window.player) {
                        const pr = window.player.radius || 26;
                        const sx = window.player.x - state.cameraX;
                        const sy = window.player.y - state.cameraY - (pr + 18);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.font = 'bold 18px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
                        ctx.strokeText('Reloading', sx, sy);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText('Reloading', sx, sy);
                        ctx.restore();
                } else {
                        try { window._weapon7ReloadingLabel = null; } catch(_) {}
                }
        } catch(_) {}
        // NPC talk tooltip when near
        (function drawNpcTalkHint(){
                if (dialogue && dialogue.open) return;
                let nearest = null; let bestD2 = Infinity; let talkR = 0;
                for (let i = 0; i < npcs.items.length; i++) {
                        const n = npcs.items[i];
                        if (!n || !n.alive) continue;
                        // Suppress talk hint for NPCs that disabled talk (or currently following)
                        if (n._disableTalk || n.state === 'follow') continue;
                        const dx = n.x - player.x, dy = n.y - player.y;
                        const d2 = dx*dx + dy*dy;
                        let r = (n.radius || 24) + (player.radius || 26) + 36;
                        try { if (typeof n.talkRangeBoost === 'number') r += Math.max(0, n.talkRangeBoost); } catch(_) {}
                        if (d2 <= r * r && d2 < bestD2) { bestD2 = d2; nearest = n; talkR = r; }
                }
                if (nearest) {
                        // Suppress NPC bark bubble while talk hint is showing
                        try { if (nearest._bark) { nearest._bark.visible = false; nearest._bark.phase = 'gap'; nearest._bark.timer = Math.max(nearest._bark.timer, 0.25); } } catch(_) {}
                        state.talkHintNpcId = nearest.id;
                        const sx = nearest.x - state.cameraX;
                        const sy = nearest.y - state.cameraY;
                        const label = 'Press E to Talk';
                        ctx.save();
                        ctx.font = 'bold 16px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const metrics = ctx.measureText(label);
                        const tw = Math.ceil(metrics.width);
                        const th = 22;
                        const padX = 10, padY = 6;
                        const bx = Math.round(sx - tw / 2 - padX);
                        const by = Math.round(sy - (nearest.radius || 24) - 36 - th / 2 - padY);
                        const bw = Math.round(tw + padX * 2);
                        const bh = Math.round(th + padY * 2);
                        // Box
                        ctx.fillStyle = 'rgba(0,0,0,0.65)';
                        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.rect(bx + 0.5, by + 0.5, bw, bh);
                        ctx.fill();
                        ctx.stroke();
                        // Text
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(label, Math.round(sx), Math.round(by + bh / 2));
                        ctx.restore();
                } else {
                        state.talkHintNpcId = null;
                }
        })();
        // Draw chests and artifacts on top of ground, below bullets front layer
        for (let i = 0; i < chests.length; i++) chests[i].draw(ctx, { x: state.cameraX, y: state.cameraY }, player);
        // Draw extraction zone overlay and UI
        if (scene.current === 'level' && extractionZone && typeof extractionZone.draw === 'function') extractionZone.draw(ctx, { x: state.cameraX, y: state.cameraY }, player);
        if (scene.current === 'level' && hereticExtractionZone && typeof hereticExtractionZone.draw === 'function') hereticExtractionZone.draw(ctx, { x: state.cameraX, y: state.cameraY }, player);
        // Draw Ready to Deploy zone in lobby
        if (scene.current === 'lobby') {
                if (!window._readyZone && window.GameObjects && window.GameObjects.ReadyZone) {
                        window._readyZone = new window.GameObjects.ReadyZone(0, 0, 300);
                }
                if (window._readyZone && typeof window._readyZone.draw === 'function') {
                        window._readyZone.draw(ctx, { x: state.cameraX, y: state.cameraY }, player);
                }
        }
    // Draw boss drops
    (function drawBossDrops(){
        if (scene.current !== 'level') return;
        const arr = window.bossDrops || [];
        for (let i = 0; i < arr.length; i++) {
            const d = arr[i];
            if (d && typeof d.draw === 'function') d.draw(ctx, { x: state.cameraX, y: state.cameraY });
        }
    })();
        // Front bullet layer (and VFX)
        if (typeof projectiles.drawLayer === 'function') projectiles.drawLayer(ctx, { x: state.cameraX, y: state.cameraY }, false);
        else projectiles.draw(ctx, { x: state.cameraX, y: state.cameraY });

        // Remove shake transform before UI
        if (__shakeApplied) ctx.restore();

        // Damage vignette overlay (dark red edges), drawn beneath UI
        if ((state.vignette || 0) > 0.001) {
                const v = Math.max(0, Math.min(1, state.vignette || 0));
                const w = state.viewportWidth;
                const h = state.viewportHeight;
                const cx = w / 2;
                const cy = h / 2;
                // Inner radius covers center safe zone, outer radius reaches corners
                const maxR = Math.hypot(cx, cy);
                const innerR = Math.max(0, maxR * 0.5);
                const outerR = Math.max(innerR + 1, maxR * 0.98);
                const g = ctx.createRadialGradient(cx, cy, innerR, cx, cy, outerR);
                // Alpha scales nonlinearly for punchy start but soft tail
                const a = Math.pow(v, 0.6) * 0.95;
                g.addColorStop(0, 'rgba(120, 0, 0, 0)');
                g.addColorStop(0.5, `rgba(100, 0, 0, ${a * 0.35})`);
                g.addColorStop(0.82, `rgba(70, 0, 0, ${a * 0.7})`);
                g.addColorStop(1, `rgba(50, 0, 0, ${a})`);
                ctx.save();
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);
                // Deepen darkness using multiply black gradient for clearer vignette
                ctx.globalCompositeOperation = 'multiply';
                const gb = ctx.createRadialGradient(cx, cy, innerR, cx, cy, outerR);
                gb.addColorStop(0, 'rgba(0,0,0,0)');
                gb.addColorStop(1, `rgba(0,0,0, ${a * 0.65})`);
                ctx.fillStyle = gb;
                ctx.fillRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over';
                ctx.restore();
        }

        // Dialogue overlay (modal)
        if (dialogue && dialogue.open && typeof dialogue.draw === 'function') {
                dialogue.draw(ctx, state.viewportWidth, state.viewportHeight);
        }


        // Scene label for clarity
        ctx.save();
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText(scene.current === 'lobby' ? 'Lobby' : 'Level', 10, 10);
        ctx.restore();

        // Extraction end overlay
        if (state.extractionEnd) {
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, state.viewportWidth, state.viewportHeight);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 48px sans-serif';
                const title = (state.extractionEnd.type === 'win') ? 'Mission Complete' : (state.extractionEnd.type === 'heretic' ? 'The heretics have stolen the artifact' : 'You Lose');
                ctx.fillStyle = '#ffffff';
                ctx.fillText(title, state.viewportWidth / 2, state.viewportHeight / 2 - 60);
                if (state.extractionEnd.reason && state.extractionEnd.type !== 'heretic') {
                        ctx.font = '20px sans-serif';
                        ctx.fillText(state.extractionEnd.reason, state.viewportWidth / 2, state.viewportHeight / 2 - 20);
                }
                // Button: Return to Lobby
                const bw = 220, bh = 56;
                const bx = Math.round(state.viewportWidth / 2 - bw / 2);
                const by = Math.round(state.viewportHeight / 2 + 20);
                ctx.fillStyle = '#2c3343';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(bx + 0.5, by + 0.5, bw, bh);
                ctx.fill();
                ctx.stroke();
                ctx.font = '22px sans-serif';
                ctx.fillStyle = '#ffffff';
                ctx.fillText('Return to Lobby', state.viewportWidth / 2, by + bh / 2 + 2);
                ctx.restore();
                state.extractionButtonRect = { x: bx, y: by, w: bw, h: bh };
        }

        // Draw NPC barks last so they appear above extraction overlays
        (function drawNpcBarksLast(){
                try {
                        const list = window._npcBarkList || [];
                        for (let i = 0; i < list.length; i++) {
                                const n = list[i];
                                if (!n || !n.alive) continue;
                                const sx = n.x - state.cameraX;
                                const sy = n.y - state.cameraY;
                                const b = n._bark;
                                if (!b || !b.visible || !Array.isArray(b.lines) || b.lines.length === 0) continue;
                                const text = String(b.lines[Math.max(0, Math.min(b.lines.length - 1, b.idx))] || '');
                                if (!text) continue;
                                const bob = Math.sin((n._t || 0) * 2.6) * 4;
                                const bx = sx;
                                const by = sy - n.radius - 48 + bob;
                                ctx.save();
                                ctx.font = '14px sans-serif';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                const metrics = ctx.measureText(text);
                                const tw = Math.ceil(metrics.width);
                                const padX = 10, padY = 6;
                                const bw = tw + padX * 2;
                                const bh = 24 + padY * 2;
                                const fade = Math.max(0, Math.min(1, b.fade || 0));
                                const scale = 0.85 + 0.15 * fade;
                                ctx.globalAlpha = 0.65 * fade;
                                ctx.translate(Math.round(bx), Math.round(by));
                                ctx.scale(scale, scale);
                                ctx.translate(-Math.round(bx), -Math.round(by));
                                ctx.fillStyle = 'rgba(0,0,0,1)';
                                ctx.strokeStyle = '#000000';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.rect(Math.round(bx - bw / 2) + 0.5, Math.round(by - bh / 2) + 0.5, bw, bh);
                                ctx.fill();
                                ctx.stroke();
                                ctx.strokeStyle = 'rgba(255,255,255,' + (0.2 * fade) + ')';
                                ctx.beginPath();
                                ctx.moveTo(bx, by + bh / 2);
                                ctx.lineTo(sx, sy - n.radius);
                                ctx.stroke();
                                ctx.globalAlpha = fade;
                                ctx.fillStyle = b.color || '#ffb15a';
                                ctx.fillText(text, Math.round(bx), Math.round(by));
                                ctx.restore();
                        }
                } catch(_) {}
                window._npcBarkList = null;
        })();

        // Guard mode guidance arrow: points to gold chest, then artifact if on the ground
        if (modeTimer.currentName === 'Guard') {
                let target = null;
                const goldChest = chests.find(c => c && c.variant === 'gold');
                if (goldChest) {
                        if (!goldChest.opened) {
                                target = { x: goldChest.x, y: goldChest.y, style: 'chest' };
                        } else if (goldChest.artifact && !goldChest.artifact.carriedBy) {
                                target = { x: goldChest.artifact.x, y: goldChest.artifact.y, style: 'artifact' };
                        }
                }
                if (target && state.arrowAlpha > 0.001) {
                        const px = player.x - state.cameraX;
                        const py = player.y - state.cameraY;
                        const dx = target.x - player.x;
                        const dy = target.y - player.y;
                        const ang = Math.atan2(dy, dx);
                        // Position the arrow a bit away from the player along the direction
                        const radius = 250;
                        const ax = px + Math.cos(ang) * radius;
                        const ay = py + Math.sin(ang) * radius;
                        ctx.save();
                        ctx.translate(ax, ay);
                        ctx.rotate(ang);
                        // Transparent arrow with color based on phase (gold chest vs blue artifact)
                        const len = 36;
                        const halfW = 10;
                        ctx.globalAlpha = 0.75 * state.arrowAlpha;
                        if (target.style === 'artifact') {
                                ctx.fillStyle = '#8af7ff';
                                ctx.strokeStyle = '#2bc7d6';
                        } else {
                                ctx.fillStyle = '#d4af37';
                                ctx.strokeStyle = '#8a6d1f';
                        }
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(len, 0);
                        ctx.lineTo(-8, halfW);
                        ctx.lineTo(-8, -halfW);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                        ctx.globalAlpha = 1.0;
                }
        }

        // While Backquote is held: show arrow to nearest NPC
        if (state.keys.Backquote) {
                let nearestA = null, bestA = Infinity;
                let nearestB = null, bestB = Infinity;
                for (let i = 0; i < npcs.items.length; i++) {
                        const n = npcs.items[i];
                        if (!n || !n.alive) continue;
                        const dx = n.x - player.x;
                        const dy = n.y - player.y;
                        const d2 = dx * dx + dy * dy;
                        if (n.name === 'NPC_A') { if (d2 < bestA) { bestA = d2; nearestA = n; } }
                        if (n.name === 'NPC_B') { if (d2 < bestB) { bestB = d2; nearestB = n; } }
                }
                const px = player.x - state.cameraX;
                const py = player.y - state.cameraY;
                const drawNpcArrow = (target, fill, stroke) => {
                        if (!target) return;
                        const dx = target.x - player.x;
                        const dy = target.y - player.y;
                        const ang = Math.atan2(dy, dx);
                        const dist = Math.hypot(dx, dy);
                        // Fade arrow when close
                        const near = 500, far = 2000;
                        let fade = 1;
                        if (dist <= near) fade = 0; else if (dist >= far) fade = 1; else fade = (dist - near) / (far - near);
                        const radius = 250;
                        const ax = px + Math.cos(ang) * radius;
                        const ay = py + Math.sin(ang) * radius;
                        ctx.save();
                        ctx.translate(ax, ay);
                        ctx.rotate(ang);
                        const len = 36;
                        const halfW = 10;
                        ctx.globalAlpha = 0.75 * fade;
                        ctx.fillStyle = fill;
                        ctx.strokeStyle = stroke;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(len, 0);
                        ctx.lineTo(-8, halfW);
                        ctx.lineTo(-8, -halfW);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                        ctx.globalAlpha = 1.0;
                };
                // NPC_A arrow (forest green)
                drawNpcArrow(nearestA, '#228b22', '#0d4f0d');
                // NPC_B arrow (maroon)
                drawNpcArrow(nearestB, '#800000', '#4d0000');
        }
        const artifactCarried = chests.some(c => c && c.artifact && c.artifact.carriedBy);
        // When carrying artifact: show arrows to Boss (red) and Extraction zone (green)
        if (artifactCarried) {
                // Boss arrow (red)
                let __conv = false; try { __conv = (typeof window !== 'undefined' && window.__killThemAllLocked === true); } catch(_) {}
                if (!__conv) {
                        let boss = null;
                        try {
                                for (let i = 0; i < enemies.items.length; i++) {
                                        const e = enemies.items[i];
                                        if (!e || !e.alive) continue;
                                        if (window.ArtilleryWitch && e instanceof window.ArtilleryWitch) { boss = e; break; }
                                }
                        } catch(e) {}
                        if (boss) {
                                const px = player.x - state.cameraX;
                                const py = player.y - state.cameraY;
                                const dx = boss.x - player.x;
                                const dy = boss.y - player.y;
                                const ang = Math.atan2(dy, dx);
                                const distToBoss = Math.hypot(dx, dy);
                                // Fade arrow when close to boss
                                const near = 500, far = 2000;
                                let fade = 1;
                                if (distToBoss <= near) fade = 0; else if (distToBoss >= far) fade = 1; else fade = (distToBoss - near) / (far - near);
                                const radius = 250;
                                const ax = px + Math.cos(ang) * radius;
                                const ay = py + Math.sin(ang) * radius;
                                ctx.save();
                                ctx.translate(ax, ay);
                                ctx.rotate(ang);
                                const len = 36;
                                const halfW = 10;
                                ctx.globalAlpha = 0.75 * fade;
                                ctx.fillStyle = '#ff4d4d';
                                ctx.strokeStyle = '#8a1f1f';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(len, 0);
                                ctx.lineTo(-8, halfW);
                                ctx.lineTo(-8, -halfW);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                ctx.restore();
                                ctx.globalAlpha = 1.0;
                        }
                }

                // Extraction zone arrow (green)
                if (!__conv && extractionZone) {
                        const px = player.x - state.cameraX;
                        const py = player.y - state.cameraY;
                        const dx = extractionZone.x - player.x;
                        const dy = extractionZone.y - player.y;
                        const ang = Math.atan2(dy, dx);
                        const distToZone = Math.hypot(dx, dy);
                        // Fade arrow when close to extraction zone
                        const nearZ = 500, farZ = 2000;
                        let fadeZ = 1;
                        if (distToZone <= nearZ) fadeZ = 0; else if (distToZone >= farZ) fadeZ = 1; else fadeZ = (distToZone - nearZ) / (farZ - nearZ);
                        const radius = 250;
                        const ax = px + Math.cos(ang) * radius;
                        const ay = py + Math.sin(ang) * radius;
                        ctx.save();
                        ctx.translate(ax, ay);
                        ctx.rotate(ang);
                        const len = 36;
                        const halfW = 10;
                        ctx.globalAlpha = 0.75 * fadeZ;
                        ctx.fillStyle = '#21f07a';
                        ctx.strokeStyle = '#0c5b34';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(len, 0);
                        ctx.lineTo(-8, halfW);
                        ctx.lineTo(-8, -halfW);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                        ctx.globalAlpha = 1.0;
                }
                // Heretic extraction zone arrow (red)
                if (hereticExtractionZone) {
                        const px = player.x - state.cameraX;
                        const py = player.y - state.cameraY;
                        const dx = hereticExtractionZone.x - player.x;
                        const dy = hereticExtractionZone.y - player.y;
                        const ang = Math.atan2(dy, dx);
                        const distToZone = Math.hypot(dx, dy);
                        const nearZ = 500, farZ = 2000;
                        let fadeZ = 1;
                        if (distToZone <= nearZ) fadeZ = 0; else if (distToZone >= farZ) fadeZ = 1; else fadeZ = (distToZone - nearZ) / (farZ - nearZ);
                        const radius = 250;
                        const ax = px + Math.cos(ang) * radius;
                        const ay = py + Math.sin(ang) * radius;
                        ctx.save();
                        ctx.translate(ax, ay);
                        ctx.rotate(ang);
                        const len = 36;
                        const halfW = 10;
                        ctx.globalAlpha = 0.75 * fadeZ;
                        ctx.fillStyle = '#ff4d4d';
                        ctx.strokeStyle = '#8a1f1f';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(len, 0);
                        ctx.lineTo(-8, halfW);
                        ctx.lineTo(-8, -halfW);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                        ctx.globalAlpha = 1.0;
                }
        }
        const equipped = (player.inventory || []).filter(Boolean);
        const inventoryCount = Math.min(6, equipped.length);
        const getEquippedColor = (idx) => (equipped[idx]?.rarity?.color || '#ffffff');
        const getEquippedLabel = (idx) => (equipped[idx]?.label || '');
        // Render other players
        renderOtherPlayers(ctx);

        ui.draw(ctx, state.viewportWidth, state.viewportHeight, player, { dead: player.health <= 0, respawnTimer: state.deathTimer, selectedSlotIndex: projectiles.currentIndex, modeName: (scene.current === 'lobby') ? null : modeTimer.currentName, modeTimeLeft: (scene.current === 'lobby') ? null : modeTimer.timeLeft, artifactCarried, inventoryCount, getEquippedColor, getEquippedLabel, mouseX: state.mouse.x, mouseY: state.mouse.y, mouseDown: state.mouseDown, weapon: projectiles.current, weaponIndex: projectiles.currentIndex, hideQuickbar: !!(dialogue && dialogue.open), quickbarFade: state.quickbarFade, invincible: state.invincible });

        // Debug overlay
        if (DEBUG) {
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.font = '12px monospace';
                const debugStatus = window.gameDebugger?.getStatus();
                const lines = [
                        `dt: ${state._lastDt?.toFixed?.(3) ?? 'n/a'}`,
                        `fps: ${debugStatus?.fps || 0}`,
                        `cam: (${state.cameraX.toFixed(1)}, ${state.cameraY.toFixed(1)})`,
                        `player: (${player.x.toFixed(1)}, ${player.y.toFixed(1)})`,
                        `mouse: (${state.mouse.x.toFixed(1)}, ${state.mouse.y.toFixed(1)})`,
                        `multiplayer: ${isMultiplayer ? 'ON' : 'OFF'}`,
                        `connected: ${window.networkManager?.connected ? 'YES' : 'NO'}`,
                        `players: ${(otherPlayers?.length || 0) + (isMultiplayer ? 1 : 0)}`,
                        `room: ${window.networkManager?.roomId || 'none'}`,
                        `debug: ${debugStatus?.enabled ? 'ON' : 'OFF'} (${debugStatus?.level || 'N/A'})`,
                        `events: net:${debugStatus?.counters?.networkMessages || 0} dmg:${debugStatus?.counters?.damageEvents || 0} enemy:${debugStatus?.counters?.enemySpawns || 0}`,
                        `inventory: changes:${debugStatus?.counters?.inventoryChanges || 0} equip:${debugStatus?.counters?.equipmentChanges || 0} status:${debugStatus?.counters?.statusEffects || 0}`,
                        `weapons: actions:${debugStatus?.counters?.weaponActions || 0} projectiles:${debugStatus?.counters?.projectilesFired || 0}`,
                        `gameflow: scenes:${debugStatus?.counters?.sceneTransitions || 0} modes:${debugStatus?.counters?.gameModeChanges || 0}`,
                        `economy: chests:${debugStatus?.counters?.chestOpenings || 0} items:${debugStatus?.counters?.itemGenerations || 0}`,
                        `bosses: events:${debugStatus?.counters?.bossEvents || 0}`
                ];
                // Move debug lines down to avoid overlap with two-row UI stat line (margin 16 + 2*18)
                const debugTop = 16 + 18 * 2 + 8;
                for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], 10, debugTop + i * 14);
                }
                ctx.restore();
        }
}

function frame(ts) {
        const dt = Math.min(0.033, (ts - state.lastTimestamp) / 1000 || 0);
        state.lastTimestamp = ts;
state._lastDt = dt;

        // Update FPS tracking
        if (window.gameDebugger) {
            window.gameDebugger.updateFps();
        }

        update(dt);
        
        // Send player input to server
        sendPlayerInput();
        
        render();

        requestAnimationFrame(frame);
}

        // Initialize multiplayer after all objects are created
        initializeMultiplayer();
        
        // CRITICAL: Deterministic world initialization - check if seed already received
        if (window.networkManager && window.networkManager.worldSeedReceived && !worldInitialized) {
                console.log('[Main] Found existing world seed during boot, initializing world immediately');
                initializeWorld(window.networkManager.worldSeed);
        }
        
        // Start the game loop
        requestAnimationFrame(frame);
        
        console.log('[Main] Bootstrap completed successfully');
        
        // CRITICAL: Start watchdog for deterministic world initialization
        startWorldInitWatchdog();
        
    } catch (error) {
        console.error('[Main] Fatal error during bootstrap:', error);
        scheduleRetry();
    }
}

// Retry function for failed bootstrap attempts
function scheduleRetry() {
    if (window.__mainBootAttempts__ < 5) {
        window.__mainBootAttempts__++;
        console.log(`[Main] Retry attempt ${window.__mainBootAttempts__}/5 in 500ms`);
        setTimeout(boot, 500);
    } else {
        console.error('[Main] Bootstrap failed after 5 attempts, giving up');
    }
}

// CRITICAL: Initialize everything when DOM is ready
function initMain() {
    console.log('[Main] DOM ready, initializing...');
    
    // First initialize canvas
    if (!initializeCanvas()) {
        console.error('[Main] Failed to initialize canvas, retrying in 100ms...');
        setTimeout(initMain, 100);
        return;
    }
    
    // Then start bootstrap
    try {
        boot();
    } catch (error) {
        console.error('[Main] Fatal error during initial boot:', error);
        scheduleRetry();
    }
}

// Start the initialization process when DOM is ready
document.addEventListener('DOMContentLoaded', initMain);
